include::variables.asciidoc[]
== Verbose Utilities

이후의 장들에서 사용할 기능들에 대해서 간단하게 짚고 넘어가도록 하겠다.

=== Copying Streams, Channels, Files, and Paths

자바 API 를 이용하여 파일을 복사하는 방법은 꽤나 많은 방법들이 사용되고 있지만 그만큼 부정확한 코드를 생성할 요지도 많은 듯 하다. 우선 `InputStream` 객체에서 `OutputStream` 객체로 데이터를 복사하는 메서드를 정의해 보자.

[source,java]
.IoUtils1.java#copy(InputStream, OutputStream)
----
    // input 에서 output 으로 데이터를 복사한다.
    // 복사된 바이트들의 개수를 반환한다.
include::codes/verbose-java-utils/src/main/java/com/github/jinahya/verbose/util/IoUtils1.java[lines=33..43]
----
<1> (`0` 보다 큰 길이를 가지는) 버퍼를 하나 생성하고
<2> `input` 객체의 {apidocs-javase}/java/io/InputStream.html#read-byte:A-[`InputStream#read(byte[\])`] 메서드에 버퍼를 전달해서 `-1`(`end-of-stream`) 이 반환되기 전까지
<3> `output` 에 {apidocs-javase}/java/io/OutputStream.html#write-byte:A-int-int-[`OutputStream#write(byte[\], int, int)`] 메서드를 이용해서 기록한다.

****
{apidocs-javase}/java/io/InputStream.html#read-byte:A-[`InputStream#read(byte[\])`] 메서드의 설명을 잘 읽어 본 후 아래 코드에 대해 생각해 보자.
[source,java]
----
        for (int length; (length = input.read(buffer)) > 0;)
----
****

두 파일을 전달받아 복사하는 메서드를 다음과 같이 구현할 수 있다.

[source,java]
.IoUtils1.java#copy(File, File)
----
    // source 에서 target 으로 데이터를 복사한다.
include::codes/verbose-java-utils/src/main/java/com/github/jinahya/verbose/util/IoUtils1.java[lines=61..68]
----
<1> `flush()` 메서드를 명시적으로 호출하여 모든 데이터가 해당 파일에 기록되는 것을 보장한다.

[TIP]
====
`OutputStream` 객체 혹은 `Writer` 객체에 값을 기록한 후 `close()` 메스드를 호출하기 전에 (혹은 필요한 때마다) `flush()` 메서드를 꼭 호출해서 쌓여(bufferd) 있는 데이터를 밀어내야 한다.
====

[CAUTION]
====
`close()` 메서드가 호출될 때 `flush()` 메서드가 자동으로 호출된다고 믿으면 안된다. 몇몇 `InputStream` 클래스와 `Writer` 클래스를 확장한 클래스들이 `close()` 메서드에서 `flush()` 메서드를 호출하도록 구현되고 (문서에) 기술되었을 뿐, `close()` 메서드를 정의한 {apidocs-javase}/java/lang/AutoCloseable.html[`java.lang.AutoCloseable`] 인터페이스와 그 인터페이스를 확장한 {apidocs-javase}/java/io/Closeable.html[`java.io.Closeable`] 인터페이스 그 어디에도 `close()` 메서드가 `flush()` 메서드를 호출한다고 기술된 부분이 없다.
====

다음은 `ReadableByteChannel` 객체와 `WritableByteChannel` 객체를 전달 받아 데이터를 복사하는 메서드이다.

[source,java]
.IoUtils2.java#copy1(ReadableByteChannel, WritableByteChannel)
----
    // readable 에서 writable 로 데이터를 복사한다.
    // 복사된 바이트의 개수를 반환한다.
include::codes/verbose-java-utils/src/main/java/com/github/jinahya/verbose/util/IoUtils2.java[lines=39..53]
----
<1> {apodocs-javase}/java/nio/channels/ReadableByteChannel.html#read-java.nio.ByteBuffer-[`ReadableByteChannel#read(ByteBuffer)`] 메서드를 이용해 데이터를 버퍼에 채운다.
<2> 버퍼를 뒤집어 (버퍼에 읽혀진 데이터를) 기록할 수 있는 상태로 만든 후
<3> {apidocs-javase}/java/nio/channels/WritableByteChannel.html#write-java.nio.ByteBuffer-[`WritableByteChannle#write(ByteBuffer)`] 메서드에 버퍼를 전달하여 기록한다.
<4> 버퍼에 남아 있는 내용을 앞쪽으로 모은다.
<5> 버퍼에 쌓여 있는 내용을 모두 기록한다.

****
`copy1(ReadableByteChannel, WritableByteChannel)` 메서드는 `write(ByteBuffer)` 메서드를 한 번만 호출하는 대신 `compact()` 메서드를 사용해서 데이터를 계속 버퍼의 앞쪽으로 모으는 작업을 한다. [참조: http://shop.oreilly.com/product/9780596002886.do[Java NIO, O'Reilly Media]]
****

[source,java]
.IoUtils2.java#copy2(ReadableByteChannel, WritableByteChannel)
----
include::codes/verbose-java-utils/src/main/java/com/github/jinahya/verbose/util/IoUtils2.java[lines=55..68]
----
<1> 버퍼에 읽혀진 모든 데이터를 기록한다.

****
`copy2(ReadableByteChannel, WritableByteChannel)` 메서드는 데이터를 앞쪽으로 모으는 작업(`compact()`)을 하지 않는 대신 버퍼에 데이터가 남아 있을 동안 `write(ByteBuffer)` 메서드를 계속 호출한다. [참조: http://shop.oreilly.com/product/9780596002886.do[Java NIO, O'Reilly Media]]
****

아래는 `java.nio.file.Path` 형의 객체 두개를 전달받아 복사하는 메서드이다.

[source,java]
.IoUtils2.java#copy1(Path, Path)
----
include::codes/verbose-java-utils/src/main/java/com/github/jinahya/verbose/util/IoUtils2.java[lines=89..97]
----
<1> 갱신된 내용이 저장소에 기록되는 것을 보장한다.

[NOTE]
====
{apidocs-javase}/java/nio/channels/FileChannel.html#force-boolean-[`FileChannel#force(boolean)`] 메서드에 `true` 값을 전달하여 데이터뿐만 아니라 변경된 https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html[메타정보]도 같이 저장되도록 할 수 있다.
====
[NOTE]
====
`FileChannel#force(boolean)` 메서드를 사용하는 대신 `FileChannel#open` 메서드에 {apidocs-javase}/java/nio/file/StandardOpenOption.html#DSYNC[`StandardOpenOption#DSYNC`] 혹을 {apidocs-javase}/java/nio/file/StandardOpenOption.html#DSYNC[`StandardOpenOption#SYNC`] 를 전달하여 자동으로 처리되게끔 할 수도 있다.
====

`FileChannel` 클래스의 {apidocs-javase}/java/nio/channels/FileChannel.html#transferTo-long-long-java.nio.channels.WritableByteChannel-[`transferTo`] 메서드와 {apidocs-javase}/java/nio/channels/FileChannel.html#transferFrom-java.nio.channels.ReadableByteChannel-long-long-[`transferFrom`] 메서드는 OS 수준의 기능을 사용함으로써 버퍼를 사용하여 읽기/쓰기를 반복하는 구문보다 효과적으로 작업을 수행한다.

다음은 `trasferTo` 메서드를 사용해서 파일을 복사하는 메서드이다.

[source,java]
.IoUtils2.java#copy2(Path, Path)
----
include::codes/verbose-java-utils/src/main/java/com/github/jinahya/verbose/util/IoUtils2.java[lines=99..112]
----

다음은 `trasferFrom` 메서드를 사용해서 파일을 복사하는 메서드이다.

[source,java]
.IoUtils2.java#copy2(Path, Path);
----
include::codes/verbose-java-utils/src/main/java/com/github/jinahya/verbose/util/IoUtils2.java[lines=114..127]
----

[CAUTION]
====
{apidocs-javase}/java/nio/channels/FileChannel.html#transferTo-long-long-java.nio.channels.WritableByteChannel-[`FileChannel#transferTo`] 메서드와 {apidocs-javase}/java/nio/channels/FileChannel.html#transferFrom-java.nio.channels.ReadableByteChannel-long-long-[`FileChannel#transferFrom`] 메서드는 `-1` 을 반환하지 않는다.
====

=== Using Message Digests

두 개의 파일이 주어졌을 때 두 파일의 내용이 같은지 어떻게 확인할 수 있을까? 두 파일을 처음부터 끝까지 바이트별로 비교하는 것도 가능한 방법중에 하나일 수 있다. 또 다른 방법은 {apidocs-javase}/java/security/MessageDigest.html[`java.security.MessageDigest`] 클래스를 이용하여 각 파일의 메시지 다이제스트 값을 구한 후 두 값을 비교하는 것이다.

다음은 `InputStream` 객체와 알고리즘 이름을 받아서 메시지 다이제스트 값을 구하는 메서드이다.

[source,java]
.MdUtils1.java#digest1(InputStream, String)
----
include::codes/verbose-java-utils/src/main/java/com/github/jinahya/verbose/util/MdUtils1.java[lines=35..44]
----
<1> `algorithm` 값을 이용하여 `MessageDigest` 객체를 생성한다.
<2> `input` 에서 데이터를 읽은 후 `digest` 객체에 갱신한다.
<3> `digest` 에서 결과값을 구하여 반환한다.

아래 메서드는 {apidocs-javase}/java/security/DigestInputStream.html[`java.security.DigestInputStream`] 클래스를 사용한다.

[source,java]
.MdUtils1.java#digest2(InputStream, String)
----
include::codes/verbose-java-utils/src/main/java/com/github/jinahya/verbose/util/MdUtils1.java[lines=46..51]
----
<1> `InputStream` 객체와 `MessageDigest` 객체를 이용하여 `DigestInputStream` 객체를 생성한다.
<2> `DigestInputStream` 의 데이터를 읽는다. (내부적으로 읽힌 데이터가 `digest` 에 갱신된다.)
<3> 결과값을 반환한다.

아래는 파일을 전달 받아 그 파일의 메시지 다이제스트를 반환하는 메서드이다.

[source,java]
.MdUtils1.java#digest(File, String)
----
include::codes/verbose-java-utils/src/main/java/com/github/jinahya/verbose/util/MdUtils1.java[lines=72..77]
----

다음은 `ReadableByteChannel` 객체에서 데이터를 읽어서 메시지 다이제스트를 계산하는 메서드이다.

[source,java]
.MdUtils2.java#digest(ReadableByteChannel, String)
----
include::codes/verbose-java-utils/src/main/java/com/github/jinahya/verbose/util/MdUtils2.java[lines=37..47]
----
<1> `buffer` 에 채워진 데이터를 `digest` 에 갱신한다.

아래는 `Path` 객체를 전달 받아 메시지 다이제스트를 반환하는 메서드이다.

[source,java]
.MdUtils2.java#digest(Path, String)
----
include::codes/verbose-java-utils/src/main/java/com/github/jinahya/verbose/util/MdUtils2.java[lines=58..63]
----

=== Implementing an interface without implementing the interface

이번주부터 당신은 고객사의 건물에 내부의 온도 센서를 전부 교체하는 프로젝트에 투입되었다. 당신에게 맞겨진 작업은 센서를 설치하는 업체에서 제공한 API 를 기존 시스템에 적용하는 작업이다.

다음은 전달된 온도계의 값을 저장하는 서비스 클래스이다.

[source,java]
----
include::../../../src/main/java/com/github/jinahya/verbose/reflect/TemperatureService.java[lines=20..25]
----

`FahrenheitThermometer` 인터페이스는 다음과 같다.

[source,java]
----
include::../../../src/main/java/com/github/jinahya/verbose/reflect/FahrenheitThermometer.java[lines=18..22]
----

하지만 새로운 온도 센서를 담당하는 업체에서 제공한 API는 화씨(&#8457;) 대신 섭씨(&#8451;)를 사용한다.

[source,java]
----
include::../../../src/main/java/com/github/jinahya/verbose/reflect/CelsiusThermometer.java[lines=18..22]
----

비용 등의 이유로 인해 `CelsiusThermometer` 인터페이스를 사용하는 새로운 비지니스 로직을 추가할 수 없을 때 어떻게 해야 할까?

가장 접근하기 쉬운 방법은 `CelsiusThermometer` 를 `FahrenheitThermometer` 로 바꿔주는 어뎁터 클래스를 작성하는 것이다.

[source,java]
----
include::../../../src/main/java/com/github/jinahya/verbose/reflect/FahrenheitThermometerAdapter.java[lines=18..31]
----

[NOTE]
====
`FahrenheitThermometer` 인터페이스에 구현해야 할 메서드가 하나밖에 없으므로 다음과 같이 lambda 표현식을 사용하는 것도 가능하다.
[source,java]
----
getTemperatureService().persistTemperature(
        () -> getCelsiusThermometer().getTemeratureInCelsius()
              * 1.8f + 32);
----
====

또 다른 방법은 {apidocs-javase}/java/lang/reflect/InvocationHandler.html[`java.lang.reflect.InvocationHandler`] 인터페이스와 {apidocs-javase}/java/lang/reflect/Proxy.html[`java.lang.reflect.Proxy`] 클래스를 이용하여 생성할 수 있는 프록시 객체를 사용하는 방법이다.

우선 다음과 같이 {apidocs-javase}/java/lang/reflect/InvocationHandler.html[`java.lang.reflect.InvocationHandler`] 인터페이스를 구현하여 `FahrenheitThermoter#getTemperatureInFahrenheit()` 메서드 호출을 가로챈 후 `CelsiusThermometer` 객체를 이용하여 계신된 화씨(&#8457;)값을 반환도록 하자.

[source,java]
----
include::../../../src/main/java/com/github/jinahya/verbose/reflect/FahrenheitThermometerHandler.java[lines=21..53]
----
<1> 호출을 가로챌 메서드(`FahrenheitThermoter#getTemperatureInFahrenheit()`)를 정의한다.
<2> `proxy` 객체에 호출된 메서드가 해당 메서드이면 `celsius` 객체를 사용하여 섭씨에서 화씨로 변한한 값을 반환한다.
<3> 다른 메서드들(e.g. `toString()`)은 `celsius` 객체에 직접 호출하고 그 결과를 반환한다.

이제 {apidocs-javase}/java/lang/reflect/Proxy.html#newProxyInstance-java.lang.ClassLoader-java.lang.Class:A-java.lang.reflect.InvocationHandler-[`Proxy#newProxyInstance(ClassLoader, Class<?>[\], InvocationHandler)`] 메서드를 이용하여 프록시 객체를 생성한다.

[source,java]
----
include::../../../src/main/java/com/github/jinahya/verbose/reflect/TemperatureSchedules.java[lines=43..47]
----

====
`InvocationHandler` 인터페이스도 구현해야 할 메서드가 하나밖에 없다. 다음은 lambda 표현식을 사용한 예제이다.
[source,java]
----
include::../../../src/main/java/com/github/jinahya/verbose/reflect/TemperatureSchedules.java[lines=75..84]
----
====

==== Mimicking Non-Blocking Channels

앞서 설명된 코드들 중 {apidocs-javase}/java/nio/channels/WritableByteChannel.html#write-java.nio.ByteBuffer-[`WritableByteChannel#write(ByteBuffer)`] 혹은 {apidocs-javase}/java/nio/channels/ReadableByteChannel.html#read-java.nio.ByteBuffer-[`ReadableByteChannel#read(ByteBuffer)`] 등의 메서드들은 해당 채널이 non-blocking 채널일 경우 버퍼의 가용한(`remaining`) 만큼의 모든 데이터를 모두 처리하지 않는다. 때문에 non-blocking 채널이라 가정하고 작성된 코드들이 예상대로 동작하는지 단위 테스트에서 확인할 수 없다.

위에서 설명된 프록시를 이용하여 특정 채널 객체를 non-blocking 채널처럼 동작하게 만들 수 있다. 방법은 간단하다. `write(ByteBuffer)` 메서드 혹은 `read(ByteBuffer)` 메서드의 호출을 가로챈 후 `limit` 값을 임의로 줄이면 된다.

[source,java]
.BcUtils.java#nonBlockingWritable(Class<T>, T)
----
// 주어진 channel 객체에 호출되는 write(ByteBuffer) 메서드를 가로채어
// limit 값을 임의로 (그리고 임시로) 변경함으로써 non-blocking 채널처럼 동작하게 한다.
public static <T extends WritableByteChannel> T nonBlocking(
        final Class<T> type, final T channel) {
    //@todo: implement
    return null;
}
----

우선 http://docs.oracle.com/javase/8/docs/api/java/nio/channels/WritableByteChannel.html#write-java.nio.ByteBuffer-[`WritableByteChannel#write(ByteBuffer)`] 메서드를 찾아서 준비힌다.

[source,java]
.BcUtils.java#nonBlockingWritable(Class<T>, T)
----
include::codes/verbose-java-utils/src/main/java/com/github/jinahya/verbose/util/BcUtils.java[lines=46..52]
----
<1> 호출을 가로챌 메서드를 찾아서 선언한다.

그 다음 `InvocationHandler` 객체를 하나 구현한다.

[source,java]
.BcUtils.java#nonBlockingWritable(Class<T>, T)
----
include::codes/verbose-java-utils/src/main/java/com/github/jinahya/verbose/util/BcUtils.java[lines=53..66]
----
<1> 호출된 메서드(`m`)가 미리 정의해 놓은 메서드(`target`, `WritableByteChannel#write(ByteBuffer)`)와 같으면
<2> 메서드에 전달된 첫 번째 인자(`a[0]`)인 버퍼를 찾아서
<3> `limit` 값을 저장해 놓은 후
<4> 버퍼의 가용한 값(`remaining`) 값을 임의로 줄여서 (마치 non-blocking 채널에 호출한 것과 같은 결과를 내도록 설정한 후)
<5> 채널에 직접 호출한 값을 반환한다.
<6> 반환하기 전에 limit 값을 복원한다.
<7> 다른 메서드들은 그대로 호출한다.

마지막으로 `Proxy#newProxyInstance` 메서드를 이용하여 프록시 객체를 생성한다.

[source,java]
.BcUtils.java#nonBlockingWritable(Class<T>, T)
----
include::codes/verbose-java-utils/src/main/java/com/github/jinahya/verbose/util/BcUtils.java[lines=67..69]
----
<1> 프록시 객체를 생성한다.
<2> 해당 형으로 변환하여 반환한다.
