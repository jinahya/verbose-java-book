include::variables.asciidoc[]
== Verbose Java Utils

이후의 장들에서 사용할 몇몇 기능들에 대해서 간단하게 짚고 넘어가도록 하자.

=== Copying Streams, Channels, Files, and Paths

자바 API 를 이용하여 데이터를 복사하는 데에는 꽤나 많은 방법들이 사용되고 있지만 그만큼 부정확한 코드를 생성할 요지도 많은 듯 하다. 우선 `InputStream` 객체에서 `OutputStream` 객체로 데이터를 복사하는 메서드를 정의해 보자.

[source,java]
.IoUtils1.java#copy(InputStream, OutputStream, byte[])
----
    // input 에서 output 으로, buffer 를 이용하여, 데이터를 복사한다.
    // 복사된 바이트들의 개수를 반환한다.
include::codes/verbose-java-utils/src/main/java/com/github/jinahya/verbose/util/IoUtils1.java[lines=40..49]
----
<1> `input` 객체의 {apidocs-javase}/java/io/InputStream.html#read-byte:A-[`InputStream#read(byte[\])`] 메서드에 `buffer` 를 전달해서 `-1`(`end-of-stream`) 이 반환되기 전까지
<2> `output` 에 {apidocs-javase}/java/io/OutputStream.html#write-byte:A-int-int-[`OutputStream#write(byte[\], int, int)`] 메서드를 이용해서 기록한다.

[TIP]
====
{project-commons-io}[Commons IO] 의 link:++https://static.javadoc.io/commons-io/commons-io/2.5/org/apache/commons/io/IOUtils.html#copyLarge(java.io.InputStream,%20java.io.OutputStream,%20byte[])++[`copyLarge(Ljava.io.InputStream;Ljava.io.OutputStream;[B)J`] 를 이용하여 동일한 기능을 수행할 수 있다.
====

[TIP]
====
{project-guava}[Guava] 의 https://google.github.io/guava/releases/23.0/api/docs/com/google/common/io/ByteStreams.html#copy-java.io.InputStream-java.io.OutputStream-[`copy(Ljava.io.InputStream;Ljava.io.OutputStream;)J`] 를 이용하여 동일한 기능을 수행할 수 있다. (내부적으로 `8192` 만큼의 크기를 가지는 버버를 사용한다.)
====

[WARNING]
====
{apidocs-javase}/java/io/InputStream.html#read-byte:A-[`InputStream#read([B)I`] 메서드의 설명을 잘 읽어 본 후 아래 코드에 대해 생각해 보자.
[source,java]
----
for (int length; (length = input.read(buffer)) > 0;)
----
====

두개의 파일을 전달받아 복사하는 메서드를 다음과 같이 구현할 수 있다.

[source,java]
.IoUtils1.java#copy(File, File, byte[])
----
    // source 에서 target 으로 데이터를 복사한다.
include::codes/verbose-java-utils/src/main/java/com/github/jinahya/verbose/util/IoUtils1.java[lines=60..69]
----
<1> `flush()` 메서드를 명시적으로 호출하여 쌓여있는(buffered) 데이터를 밀어낸다.

[TIP]
====
`OutputStream` 객체 혹은 `Writer` 객체에 값을 기록한 후 `close()` 메스드를 호출하기 전에 (혹은 필요한 때마다) `flush()` 메서드를 꼭 호출해서 (아직 OS 수준으로 전달되지 않은 채) 쌓여있는 데이터를 밀어내야 한다.
====

[CAUTION]
====
`close()` 메서드가 호출될 때 `flush()` 메서드가 자동으로 호출된다고 믿으면 안된다. 몇몇 `InputStream` 클래스와 `Writer` 클래스를 확장한 클래스들이 `close()` 메서드에서 `flush()` 메서드를 호출하도록 구현되고 (문서에) 기술되었을 뿐, `close()` 메서드를 정의한 {apidocs-javase}/java/lang/AutoCloseable.html[`java.lang.AutoCloseable`] 인터페이스와 그 인터페이스를 확장한 {apidocs-javase}/java/io/Closeable.html[`java.io.Closeable`] 인터페이스 그 어디에도 `close()` 메서드가 `flush()` 메서드를 호출한다고 기술된 부분이 없다.
====

다음은 `ReadableByteChannel` 객체와 `WritableByteChannel` 객체를 전달 받아 데이터를 복사하는 메서드이다.

[source,java]
.IoUtils2.java#copy1(ReadableByteChannel, WritableByteChannel, ByteBuffer)
----
    // readable 에서 writable 로 데이터를 복사한다.
    // 복사된 바이트의 개수를 반환한다.
include::codes/verbose-java-utils/src/main/java/com/github/jinahya/verbose/util/IoUtils2.java[lines=45..60]
----
<1> {apodocs-javase}/java/nio/channels/ReadableByteChannel.html#read-java.nio.ByteBuffer-[`ReadableByteChannel#read(ByteBuffer)`] 메서드를 이용해 데이터를 버퍼에 채운다.
<2> 버퍼를 뒤집어 (버퍼에 읽혀진 데이터를) 기록할 수 있는 상태로 만든 후
<3> {apidocs-javase}/java/nio/channels/WritableByteChannel.html#write-java.nio.ByteBuffer-[`WritableByteChannle#write(ByteBuffer)`] 메서드에 버퍼를 전달하여 기록한다.
<4> 버퍼에 남아 있는 내용을 앞쪽으로 모은다.
<5> 버퍼에 쌓여 있는 내용을 모두 기록한다.

****
`copy1(ReadableByteChannel, WritableByteChannel, ByteBuffer)` 메서드는 `write(ByteBuffer)` 메서드를 한 번만 호출하는 대신 `compact()` 메서드를 사용해서 (아직 기록되지 않은) 데이터를 계속 버퍼의 앞쪽으로 모으는 작업을 한다. +
[참조: http://shop.oreilly.com/product/9780596002886.do[Java NIO, O'Reilly Media]]
****

[source,java]
.IoUtils2.java#copy2(ReadableByteChannel, WritableByteChannel, ByteBuffer)
----
include::codes/verbose-java-utils/src/main/java/com/github/jinahya/verbose/util/IoUtils2.java[lines=62..76]
----
<1> 버퍼에 읽혀진 모든 데이터를 기록한다.

****
`copy2(ReadableByteChannel, WritableByteChannel, ByteBuffer)` 메서드는 데이터를 앞쪽으로 모으는 작업(`compact()`)을 하지 않는 대신 버퍼에 데이터가 남아 있을 동안 `write(ByteBuffer)` 메서드를 계속 호출한다. +
[참조: http://shop.oreilly.com/product/9780596002886.do[Java NIO, O'Reilly Media]]
****

아래는 `java.nio.file.Path` 형의 객체 두개를 전달받아 복사하는 메서드이다.

[source,java]
.IoUtils2.java#copy1(Path, Path, ByteBuffer)
----
include::codes/verbose-java-utils/src/main/java/com/github/jinahya/verbose/util/IoUtils2.java[lines=91..101]
----
<1> 갱신된 내용이 저장소에 기록되는 것을 보장한다. ('true` 값을 전달하여 데이터뿐만 아니라 변경된 https://docs.oracle.com/javase/tutorial/essential/io/fileAttr.html[메타정보]도 같이 저장되도록 할 수 있다.)

[TIP]
====
`FileChannel#force(boolean)` 메서드를 사용하는 대신 `FileChannel#open` 메서드에 {apidocs-javase}/java/nio/file/StandardOpenOption.html#DSYNC[`StandardOpenOption#DSYNC`] 혹은 {apidocs-javase}/java/nio/file/StandardOpenOption.html#DSYNC[`StandardOpenOption#SYNC`] 를 전달하여 자동으로 처리되게끔 할 수도 있다.
====

`FileChannel` 클래스의 {apidocs-javase}/java/nio/channels/FileChannel.html#transferTo-long-long-java.nio.channels.WritableByteChannel-[`transferTo`] 메서드와 {apidocs-javase}/java/nio/channels/FileChannel.html#transferFrom-java.nio.channels.ReadableByteChannel-long-long-[`transferFrom`] 메서드는 OS 수준의 기능을 사용함으로써 버퍼를 사용하여 읽기/쓰기를 반복하는 구문보다 효과적으로 작업을 수행한다.

다음은 `trasferTo` 메서드를 사용해서 파일을 복사하는 메서드이다.

[source,java]
.IoUtils2.java#copy3(Path, Path)
----
include::codes/verbose-java-utils/src/main/java/com/github/jinahya/verbose/util/IoUtils2.java[lines=114..124]
----

다음은 `trasferFrom` 메서드를 사용해서 파일을 복사하는 메서드이다.

[source,java]
.IoUtils2.java#copy4(Path, Path);
----
include::codes/verbose-java-utils/src/main/java/com/github/jinahya/verbose/util/IoUtils2.java[lines=126..136]
----

[CAUTION]
====
{apidocs-javase}/java/nio/channels/FileChannel.html#transferTo-long-long-java.nio.channels.WritableByteChannel-[`FileChannel#transferTo`] 메서드와 {apidocs-javase}/java/nio/channels/FileChannel.html#transferFrom-java.nio.channels.ReadableByteChannel-long-long-[`FileChannel#transferFrom`] 메서드는 `-1` 을 반환하지 않는다.
====

=== Using java.security.MessageDigest

두 개의 파일이 주어졌을 때 두 파일의 내용이 같은지 어떻게 확인할 수 있을까? 두 파일을 처음부터 끝까지 각 바이트별로 비교하는 것도 가능한 방법중에 하나일 수 있다. 또 다른 방법은 {apidocs-javase}/java/security/MessageDigest.html[`java.security.MessageDigest`] 클래스를 이용하여 각 파일의 메시지 다이제스트 값을 구한 후 두 값을 비교하는 것이다.

다음은 알고리즘 식별자 하나와 `InputStream` 객체 하나를 받아서 메시지 다이제스트 값을 구하는 메서드이다.

[source,java]
.MdUtils1.java#digest1(String, InputStream, byte[])
----
include::codes/verbose-java-utils/src/main/java/com/github/jinahya/verbose/util/MdUtils1.java[lines=42..50]
----
<1> `algorithm` 값을 이용하여 `MessageDigest` 객체를 생성한다.
<2> `input` 에서 데이터를 읽은 후 `digest` 객체에 갱신한다.
<3> `digest` 에서 결과값을 구하여 반환한다.

아래 메서드는 {apidocs-javase}/java/security/DigestInputStream.html[`java.security.DigestInputStream`] 클래스를 사용한다.

[source,java]
.MdUtils1.java#digest2(String, InputStream)
----
include::codes/verbose-java-utils/src/main/java/com/github/jinahya/verbose/util/MdUtils1.java[lines=52..59]
----
<1> `InputStream` 객체와 `MessageDigest` 객체를 이용하여 `DigestInputStream` 객체를 생성한다.
<2> `DigestInputStream` 의 데이터를 모두 읽는다. (내부적으로 읽힌 데이터가 `digest` 에 갱신된다.)
<3> 결과값을 반환한다.

아래는 파일을 전달 받아 그 파일의 메시지 다이제스트를 반환하는 메서드이다.

[source,java]
.MdUtils1.java#digest(String, File, byte[])
----
include::codes/verbose-java-utils/src/main/java/com/github/jinahya/verbose/util/MdUtils1.java[lines=72..79]
----
<1> `digest(...)` 메서드는 내부적으로 `digest1(...)` 혹은 `digest2(...)` 를 호출한다.

다음은 `ReadableByteChannel` 객체에서 데이터를 읽어서 메시지 다이제스트를 계산하는 메서드이다.

[source,java]
.MdUtils2.java#digest(String, ReadableByteChannel, ByteBuffer)
----
include::codes/verbose-java-utils/src/main/java/com/github/jinahya/verbose/util/MdUtils2.java[lines=44..56]
----
<1> `buffer` 에 채워진 데이터를 `digest` 에 갱신한다.

아래는 `Path` 객체를 전달 받아 메시지 다이제스트를 반환하는 메서드이다.

[source,java]
.MdUtils2.java#digest(String, Path, ByteBuffer)
----
include::codes/verbose-java-utils/src/main/java/com/github/jinahya/verbose/util/MdUtils2.java[lines=69..76]
----
<1> `digest(...)` 메서드는 내부적으로 `digest1(...)` 을 호출한다.

=== Implementing an interface without implementing the interface

`HelloWorld` 인터페이스를 구현한 어떤 클래스가 주어졌을 때 각 메서드에서 로그를 남기려면 어떻게 해야 할까? 물론, 다음과 같이 그 클래스를 확장하여 로그를 남기는 코드를 삽입하면 된다.

[source,java]
----
// 로그를 추가하기 위해 확장됨.
include::../../../src/main/java/com/github/jinahya/verbose/hello/ExtendedHelloWorldImpl.java[lines=29..40]
----

또 다른 방법은 {apidocs-javase}/java/lang/reflect/InvocationHandler.html[`java.lang.reflect.InvocationHandler`] 인터페이스와 {apidocs-javase}/java/lang/reflect/Proxy.html[`java.lang.reflect.Proxy`] 클래스를 이용하여 생성할 수 있는 프록시 객체를 사용하는 방법이다.

우선 다음과 같이 {apidocs-javase}/java/lang/reflect/InvocationHandler.html[`java.lang.reflect.InvocationHandler`] 인터페이스를 구현하여 `HelloWorld` 인터페이스에 정의된 메서드들의 호출을 가로챈 후, 실제로 메서드를 호출하기 전에, 로그를 기록하자.

[source,java]
.HelloWorldInvocationHandler.java
----
include::../../../src/main/java/com/github/jinahya/verbose/hello/HelloWorldInvocationHandler.java[lines=33..41]
include::../../../src/main/java/com/github/jinahya/verbose/hello/HelloWorldInvocationHandler.java[lines=56..58]
----
<1> 생성자에서 `HelloWorld` 형의 객체를 하나 전달받은 후 필드에 저장해 놓는다.

이제 {apidoc-javase}/java/lang/reflect/InvocationHandler.html#invoke-java.lang.Object-java.lang.reflect.Method-java.lang.Object:A-[invoke(Object, Method, Object[])] 메서드를 구현하자.

[source,java]
.HelloWorldInvocationHandler.java#invoke(Object, Method, Object[])
----
include::../../../src/main/java/com/github/jinahya/verbose/hello/HelloWorldInvocationHandler.java[lines=43..55]
----
<1> 호출된 메서드가 `HelloWorld` 인터페이스에 정의된 것이라면 메서드와 인자들에 관한 정보를 로그로 남긴다.
<2> 해당 메서드와 인자들을 실제 `HelloWorld` 객체에 적용한 후 그 결과를 반환한다.

이제 {apidocs-javase}/java/lang/reflect/Proxy.html#newProxyInstance-java.lang.ClassLoader-java.lang.Class:A-java.lang.reflect.InvocationHandler-[`Proxy#newProxyInstance(ClassLoader, Class<?>[], InvocationHandler)`] 메서드를 이용하여 프록시 객체를 생성할 수 있다.

[source,java]
----
include::../../../src/main/java/com/github/jinahya/verbose/hello/HelloWorldProxy.java[lines=27..32]
----

아래는 위에서 언급된 두 클래스를 시험하는 코드와 그 결과이다.

[source,java]
----
include::../../../src/test/java/com/github/jinahya/verbose/hello/HelloWorldProxyTest.java[lines=35..39]
----
<1> `HelloWorld` 객체가 하나 있다고 가정한다.
<2> proxy 객체를 생성한다.
<3> 생성된 proxy 객체에 특정 메서드를 호출한다.

[source,txt]
----
------------------------ com.....HelloWorldInvocationHandler invoke
INFO: invoking public abstract void com.....HelloWorld.set(byte[],int) with [null, 0]
----

====
`InvocationHandler` 인터페이스도 구현해야 할 메서드가 하나밖에 없다. 다음은 lambda 표현식을 사용한 예제이다.
[source,java]
----
include::../../../src/test/java/com/github/jinahya/verbose/hello/HelloWorldProxyTest.java[lines=44..58]
----
====

==== Mimicking Non-Blocking Channels

앞서 설명된 코드들 중 {apidocs-javase}/java/nio/channels/WritableByteChannel.html#write-java.nio.ByteBuffer-[`WritableByteChannel#write(ByteBuffer)`] 혹은 {apidocs-javase}/java/nio/channels/ReadableByteChannel.html#read-java.nio.ByteBuffer-[`ReadableByteChannel#read(ByteBuffer)`] 등의 메서드들은 해당 채널이 non-blocking 채널일 경우 버퍼의 가 용한(`remaining`) 만큼의 모든 데이터를 모두 처리하지 않는다. 때문에 non-blocking 채널이라 가정하고 작성된 코드들이 예상대로 동작하는지 단위 테스트에서 확인할 수 없다.

위에서 설명된 프록시를 이용하여 특정 채널 객체를 non-blocking 채널처럼 동작하게 만들 수 있다. 방법은 간단하다. `write(ByteBuffer)` 메서드 혹은 `read(ByteBuffer)` 메서드의 호출을 가로챈 후 버퍼 인자의 `remaining (limit - position)` 값을 임의로, 그리고 임시로, 줄이면 된다.

[source,java]
.BcUtils.java#nonBlocking(Class<T>, T)
----
// 주어진 channel 객체에 호출되는 write(ByteBuffer) 메서드를 가로채어
// limit 값을 임의로 (그리고 임시로) 변경함으로써 non-blocking 채널처럼 동작하게 한다.
public static <T extends WritableByteChannel> T nonBlocking(
        final Class<T> type, final T channel) {
    //@todo: implement
    return null;
}
----

우선 http://docs.oracle.com/javase/8/docs/api/java/nio/channels/WritableByteChannel.html#write-java.nio.ByteBuffer-[`WritableByteChannel#write(ByteBuffer)`] 메서드를 찾아서 준비한다.

[source,java]
.BcUtils.java#nonBlocking(Class<T>, T)
----
include::codes/verbose-java-utils/src/main/java/com/github/jinahya/verbose/util/BcUtils.java[lines=53..59]
----
<1> 호출을 가로챌 메서드(`WritableByteChannel#write(ByteBuffer)`)를 찾아서 선언한다.

그 다음 `InvocationHandler` 객체를 하나 구현한다.

[source,java]
.BcUtils.java#nonBlocking(Class<T>, T)
----
include::codes/verbose-java-utils/src/main/java/com/github/jinahya/verbose/util/BcUtils.java[lines=60..73]
----
<1> 호출된 메서드(`m`)가 미리 정의해 놓은 메서드(`target`, `WritableByteChannel#write(ByteBuffer)`)와 같으면
<2> 메서드에 전달된 첫 번째 인자(`a[0]`)인 버퍼를 찾아서
<3> `limit` 값을 저장해 놓은 후
<4> 버퍼의 가용한 값(`remaining`) 값을 임의로 줄여서 (마치 non-blocking 채널에 호출한 것과 같은 결과를 내도록 설정한 후)
<5> 채널에 직접 호출한 값을 반환한다.
<6> 반환하기 전에 limit 값을 복원한다.
<7> 다른 메서드들은 그대로 호출한다.

마지막으로 `Proxy#newProxyInstance` 메서드를 이용하여 프록시 객체를 생성한다.

[source,java]
.BcUtils.java#nonBlocking(Class<T>, T)
----
include::codes/verbose-java-utils/src/main/java/com/github/jinahya/verbose/util/BcUtils.java[lines=74..76]
----
<1> 프록시 객체를 생성한다.
<2> 해당 형으로 변환하여 반환한다.

같은 파일(`BcUtils.java`) 에 `ReadableByteChannel` 에 해당하는 메서드들이 같이 구현되어 있다 .

=== Exercises

. `IoUtils1.java#copy1(InputStream, OutputStream, byte[])` 메서드의 세번째 인자(`byte[]`)의 길이(`length`)가 `0` 이면 어떤 현상이 발생할까?
+
{apidocs-javase}/java/io/InputStream.html#read-byte:A-[`InputStream#read(byte[])`] 메서드의 설명을 잘 읽어본 후 문제점이 예상된다면 수정하라.
+
아래에 부가적으로 추가될 수 있는 코드들이 있다.
+
[source,java]
.IoUtils1#copy1(InputStream, OutputStream, byte[])
----
    public long copy1(final InputStream input, final OutputStream out,
                      final byte[] buffer) {
        if (input == null) {
            throw new NullPointerException("input is null");
        }
        if (output == null) {
            throw new NullPointerException("output is null");
        }
        if (buffer == null) {
            throw new NullPointerException("buffer is null");
        }
        // buffer.length 가 0 일때 아래 코드에서 무슨 일이 일어날까?
        // ...
include::codes/verbose-java-utils/src/main/java/com/github/jinahya/verbose/util/IoUtils1.java[lines=45..45]
        // ...
    }
----

. 위 항목과 동일한 문제점이 있는 코드를 모두 수정하라.

. `IoUtils2.java#copy1(ReadableByteChannel, WritableByteChannel, ByteBuffer)` 메서드의 세번째 인자(`ByteBuffer`)의 용양(`capacity`)이 `0` 이면 어떤 현상이 발생할까?
+
{apidocs-javase}/api/java/nio/channels/ReadableByteChannel.html#read-java.nio.ByteBuffer-[`ReadableByteChannel#read(ByteBuffer)`]의 내용을 잘 읽어본 후 문제점이 예상된다면 수정하라.
+
[source,java]
.IoUtils2#copy1(ReadableByteChannel, WritableByteChannel, ByteBuffer)
----
    public long copy1(final ReadableByteChannel redable, final WritableByteChannel writable,
                      final ByteBuffer buffer) {
        if (readable == null) {
            throw new NullPointerException("readableis null");
        }
        if (!readable.isOpen()) {
            throw new IllegalArgumentException("readable is not open");
        }
        if (writable == null) {
            throw new NullPointerException("writable is null");
        }
        if (!writable.isOpen()) {
            throw new IllegalArgumentException("writable is not open");
        }
        if (buffer == null) {
            throw new NullPointerException("buffer is null");
        }
        // buffer.capacity 가 0 일때 아래 코드에서 무슨 일이 일어날까?
        // ...
include::codes/verbose-java-utils/src/main/java/com/github/jinahya/verbose/util/IoUtils2.java[lines=51..51]
        // ...
    }
----

. 위 항목과 동일할 문제점이 있는 코드를 모두 수정하라.

. `BcUtils.java#nonBlocking` 메서드의 `type` 인자가 {apidocs-javase}/java/nio/channels/spi/AbstractSelectableChannel.html[`AbstractSelectableChannel`] 클래스를 확장한 형이고 `channel` 인자의 {apidocs-javase}/java/nio/channels/spi/AbstractSelectableChannel.html#isBlocking--[`isBlocking`] 메서드가 `true` 를 반환한다면 굳이 non-blocking 을 흉내내기 위한 proxy 객체를 만들어서 반환할 필요가 없다.
+
해당 기능을 구현하라. 아래는 예시이다.
+
[source,java]
.BcUtils.java#nonBlocking(Class<T>, T)
----
public static <T extends WritableByteChannel> T nonBlocking(
        final Class<T> type, final T channel) {
    // T 가 AbstractSelectableChannel 의 하위 형이고
    // isBlocking() 메서드가 true 를 반환한다면
    // 해당 채널을 그대로 반환한다.
    if (AbstractSelectableChannel.class.isAssignableFrom(type)
        && !((AbstractSelectableChannel) channel).isBlocking()) {
        // channel is an instance of AbstractSelectableChannel
        // and is aleady a non-blocking one
        return channel;
    }
    // ...
}
----
+
[source,java]
.BcUtils.java#nonBlocking(Class<T>, T)
----
public static <T extends ReadableByteChannel> T nonBlocking(
        final Class<T> type, final T channel) {
    try {
        if (!(AbstractSelectableChannel) channel).isBlocking()) {
            // channel is already a non-blocking one
            return channel;
        }
    } catch (final ClassCastException cce) {
        // channel is not even an instance of AbstractSelectableChannel
    }
    // ...
)
----

. `BcUtils.java#nonBlocking` 메서드에서는, 해당 메서드가 호출될 때마다, `WritableByteChannel` 클래스의 `write(Ljava.nio.ByteBuffer;)V` 메서드를 찾아서 사용한다.
+
[source,java]
.BcUtils.java#nonBlocking(Class<T>, T)
----
        // ...
include::codes/verbose-java-utils/src/main/java/com/github/jinahya/verbose/util/BcUtils.java[lines=53..59]
        // ...
----
해당 메서드 객체를 클래스 변수로 사용하도록 변경하라.
+
[source,java]
.BcUtils.java
----
    private static final Method WRITABLE_W; // WritableByteChannel#write(ByteBuffer)

    static {
        try {
            WRITABLE_W = WritableByteChanel.class.getMethod
                    ("write", ByteBuffer.class);
        } catch (final NoSuchMethodException nsme) {
            throw new InstantiationError(nsme.getMessage());
        }
    }
----

. `BcUtils.java` 에서, 위 항목에서 언급된 것 처럼, `ReadableByteChannel#read(ByteBuffer)` 에 해당하는 메서드 객체를 클래스 변수로 서언한 뒤 사용하도록 변경하라. 
