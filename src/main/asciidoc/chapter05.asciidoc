== Numbers and Characters

[quote, Unknown]
________________________________________________________________________________
컴퓨터는 0과 1밖에 모르는 바보다.
________________________________________________________________________________

[quote, 지은이]
________________________________________________________________________________
0과 1밖에 모르는 어떤 '바보' 보다 더 똑똑한 사람을 본 적이 없다.
________________________________________________________________________________

본 장에서는 '숫자' 밖에 모르는 컴퓨터와 '문자' 를 사용하는 사람 사이에 종종 발생하는 문제점들을 해결하는 방법들을 살펴본다. 우선 자바의 자료형에 대해 간략히 알아본 후 http://tools.ietf.org/html/rfc4648#section-8[Base 16 Encoding]과 https://tools.ietf.org/html/rfc3986#section-2.1[Percent-Encoding]에 대해 알아보자.

=== Types and Values

****
자바의 `int` 형은 몇 비트인가요? `signed` 인가요? 아니면 `unsigned` 인가요? 표현할 수 있는 최소값과 최대값은 무엇인가요?
****

위의 질문들에 대한 올바른 답을 아직 모른다면 [https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html[JSL 4. Types, Values, and Variables]] 항목을 꼭 읽어보도록 하자. 원시형을 중심으로 해당 항목을 요약하자면 다음과 같다.

- 자바 프로그래밍 언어에는 두가지 데이터 형이 있다. 하나는 원시형(primitive types)이고 또 다른 하나는 참조형(reference types)이다.
- 원시형(primitive types)에는 `boolean` 과 수치형(numeric types)이 있다.
- 수치형(numeric types)에는 정수형(integral types)과 부동소수점형(floating-point types)이 있다.
- 정수형(integral types)에는 `byte`, `short`, `int`, `long`, 그리고 `char` 가 이다.
- 부동소수점형(floating-point types)에는 `float` 과 `double` 이 있다.

[options="header"]
.Primitive types
|===============================================================================
 |type       |                   |          |size|signed
 |NumericType|IntegralType      m|*byte*   m| *8*|yes
 |           |                  m|*short*  m|*16*|yes
 |           |                  m|*int*    m|*32*|yes
 |           |                  m|*long*   m|*64*|yes
 |           |                  m|*char*   m|*16*|
 |           |FloatingPointType m|*float*  m|*32*|yes
 |           |                  m|*double* m|*64*|yes
m|*boolean*  |                   |          |    |
|===============================================================================

****
자바의 정수형(integral types) 중에 unsigned 형이 존재하는가? 있다면 무엇인가?
****

=== N-bit signed two's-compliment integers

자바의 `byte`, `short`, `int`, `long` 형은 각각 `8`, `16`, `32`, `64` 비트로 이루어져 있고 부호를 가지며 2의 보수체계를 사용한다.

N개의 비트로 이루어져 있고 부호를 가지며 2의 보수체계를 사용하는 정수형로 표현할 수 있는 값의 범위는 무엇일까? 아래 세개의 비트를 가지고 실험해 보자. `000` 부터 시계방향으로 1씩 더하면서 계산해 보자.

[source,text]
.3-bit signed two's-compliment integer
----
       +1
         \ 000  0
  -1  111 \ 001  1
   -2  110 \ 010  2
    -3  101 \ 011  3  MAX
MIN  -4  100 \
              +1
----

보는 바와 같이 `011` 에서 `1` 을 더했을때 `100` 이 되지만 첫번째 비트가 `1` 이므로 음수(`-4`)로 처리된다. 최대값은 첫번째 비트가 `0` 이고 나머지 모든 비트가 `1` 인 값이고 최소값은 첫번째 비트가 `1` 이고 나머지 비트가 모두 `0` 인 값이다. 이를 수식으로 표현하면 최대값은 `+2^n-1^-1` 이고 최소값은 `-2^n-1^` 이다.

****
크기가 1 비트이고 부호를 가지며 2의 보수 체계를 사용하는 정수형으로 표현할 수 있는 최대값과 최소값은 무엇인가?
****

****
`char` 형은 `16` 비트로 이루어져 있고 부호를 사용하지 않는다. 각각의 값이 UTF-16 코드 단위를 표현한다.
****

=== IEEE 754 floating-point numbers

자바의 `float` 형과 `double` 형은 https://standards.ieee.org/findstds/standard/754-1985.html[IEEE 754-1985] 에 정의된 단정도(single-precision, 32-bit)와 배정도(double-precision, 64-bit)를 표현한다.

=== hex-codec-api

거의 모든 컴퓨터들은 자료를 저장할 때, `octet` 으로 불리는, 여덟개의 비트로 구성된 최소 단위의 숫자들로 나누어 저장한다. 'a' 라는 문자는 (`US-ASCII` 로 인코딩 되었을 때) `01100001` 로, '홍' 이라는 문자는 (`UTF-8` 로 인코딩 되었을 때) `111011011 00110011 0001101` 로 저장된다. 아래 표에 여덟개의 비트로 표현할 수 있는 몇몇 값들을 10진법, 8진법, 2진법, 그리고 자바의 `byte` 값으로 표현하였다.

[cols=">1,>1,>1,>1,<2",frame="top",options="header"]
.8-bit values
|====
|base10|base8|base2     |byte  |notes
|   `0`|  `0`|       `0`|   `0`|
|  `15`| `17`|    `1111`|  `15`|
|  `31`| `37`|   `11111`|  `31`|
|  `63`| `77`|  `111111`|  `63`|
| `127`|`177`| `1111111`| `127`|`Byte.MAX_VALUE`
| `128`|`200`|`10000000`|`-128`|`Byte.MIN_VALUE`
| `192`|`300`|`11000000`| `-64`|
| `224`|`340`|`11100000`| `-32`|
| `240`|`360`|`11110000`| `-16`|
| `255`|`377`|`11111111`|  `-1`|
|====

자바의 `byte` 형은 여덟개의 비트를 사용하고 부호를 가지며 2의 보수체계를 사용한다.

[source,text]
.8-bit signed two's-compliment integer
----
                         +1
                           \ 00000000  0
               -1  11111111 \ ........
                    ........ \ ........
                     ........ \ 01111111  127  Byte.MAX_VALUE
Byte.MIN_VALUE  -128  10000000 \
                                +1
----

거의 모든 문자셋의 기본이 되는 `US-ASCII` 문자셋에는 줄바뀜(CR, LF), 탭(TAB) 등의 제어 문자들과 보통의 자판에서 찾아볼 수 있는 문자들을 포함하여 `128`(`2^7^`)개의 코드가 정의되어 있다. 때문에 여덟개의 비트로 표현할 수 있는 `256`(`2^8^`)개의 수에 모든 문자를 할당하는 것이 불가능하다. 이를 해결하는 방법 중에 하나가 `base16`(`hex`) 로 표현하는 것이다. `base16` 표기는 여덟 개의 비트를 네 개씩 두 그룹으로 나눈 후에 각 그룹의 값을 미리 정의된 문자들 중 하나로 표현한다.

우선 아래와 같이 여덟 개의 비트를 네 개씩 두 그룹으로 나눈다.

[source,text]
----
index  7 6 5 4 3 2 1 0
upper  H H H H
lower          L L L L
----

그리고 (네 개의 비트로 표현되는) 각 그룹의 값(`0` ~ `15`)을 아래 표에 정의된 열 여섯개의 문자들 중 하나로 변환한다. (한 개의 바이트가 두개의 문자로 변환된다.)

[cols=">, >, >, >", options="header"]
.hexadecimal encoding/decoding
|====
|decoded binary|decoded value|encoded character|encoded value
|           `0`|    `0 (0x0)`|            `'0'`|  `48 (0x30)`
|           `1`|    `1 (0x1)`|            `'1'`|  `49 (0x31)`
|          `10`|    `2 (0x2)`|            `'2'`|  `50 (0x32)`
|          `11`|    `3 (0x3)`|            `'3'`|  `51 (0x33)`
|         `100`|    `4 (0x4)`|            `'4'`|  `52 (0x34)`
|         `101`|    `5 (0x5)`|            `'5'`|  `53 (0x35)`
|         `110`|    `6 (0x6)`|            `'6'`|  `54 (0x36)`
|         `111`|    `7 (0x7)`|            `'7'`|  `55 (0x37)`
|        `1000`|    `8 (0x8)`|            `'8'`|  `56 (0x38)`
|        `1001`|    `9 (0x9)`|            `'9'`|  `57 (0x39)`
|        `1010`|   `10 (0xA)`|            `'A'`|  `65 (0x41)`
|        `1011`|   `11 (0xB)`|            `'B'`|  `66 (0x42)`
|        `1100`|   `12 (0xC)`|            `'C'`|  `67 (0x43)`
|        `1101`|   `13 (0xD)`|            `'D'`|  `68 (0x44)`
|        `1110`|   `14 (0xE)`|            `'E'`|  `69 (0x45)`
|        `1111`|   `15 (0xF)`|            `'F'`|  `70 (0x46)`
|====

NOTE: `10` 부터 `15` 까지의 숫자를 소문자(`'a'` 부터 `'f'` 까지)로 변환해도 된다.

아래는 `hello, world` 가 `base16` 으로 인코딩될 때 적용되는 방식을 보여준다.

[source,text]
----
    0                    7                      15                      23
    h  e  l  l  o  , SP  w  o  r  l  d
   -- -- -- -- -- -- -- -- -- -- -- --
0x 68 65 6C 6C 6F 2C 20 77 6F 72 6C 64
   --                --
    \                 \-----------------\
   -- --                               -- --
    6  8  6  5  6  C  6  C  6  F  2  C  2  0  7  7  6  F  7  2  6  C  6  4
   -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
0x 36 38 36 35 36 43 36 43 36 46 32 43 32 30 37 37 36 46 37 32 36 43 36 34
----

첫 번째 문자 `'h'` 의  ascii 값은 `104` 이다. 이를 이진수로 표현하면 `01101000` 이고 이를 각 네 자리씩으로 나눈 `0110` 과 `1000` 에 대해 첫 번째 그룹의 값(`6`)에 해당하는 문자 `'6'` 과 두 번째 그룹의 값(`8`)에 해당하는 문자 `'8'` 이 결과값이다.
[source,text]
----
'h' = 0110 1000  (104, 0x68)
      0110       (  6, 0x06)    =>    '6' = 0011 0110  ( 54, 0x36)
           1000  (  8, 0x08)    =>    '8' = 0011 1000  ( 56, 0x38)
----

일곱번 째 문자(`'{nbsp}'`)의 ascii 값은 `32`(`00100000`)이다. 이를 각 네 자리씩으로 나눈 `0010` 과 `0000` 에 대해 첫 번째 그룹의 값(`2`)에 해당하는 문자 `'2'` 와 두 번째 그룹의 값(`0`)에 해당하는 문자 `'0'` 이 결과값이다.
[source,text]
----
' ' = 0010 0000  ( 32, 0x20)
      0010       (  2, 0x02)    =>    '2' = 0011 0010  ( 50, 0x32)
           0000  (  0, 0x00)    =>    '0' = 0011 0000  ( 48, 0x30)
----

hex-codec-api 모듈에는 `Base 16 Encoding` 을 위한 두 개의 인터페이스가 정의되어 있다.

==== HexEncoder.java

숫자들을 `base16` 문자들로 변환하기 위한 인터페이스이다.

[source,java]
.HexEncoder.java
----
@FunctionalInterface
public interface HexEncoder {

    // 주어진 숫자(decoded)를 두개의 hex 문자로 변환하여 버퍼(encoded)에 담는다.
    // 버퍼(encoded)에 담을 수 있는 공간(remaining)이 2 보다 작으면 BufferOverflowException 을 던진다.
    void encodeOctet(int decoded, ByteBuffer encoded);
}
----

`HexEncoder` 인터페이스에는 다음과 같은 `default` 메서드들이 정의되어 있다.

===== encode(ByteBuffer, ByteBuffer)

두 개의 버퍼를 전달받아서 첫 번째 버퍼의 숫자들을 변환하여 두 번째 버퍼에 담는 메서드이다.

[source,java]
.HexEncoder.java#encode(ByteBuffer, ByteBuffer)
----
    // decoded 버퍼에 남아있는(remaining) 각각의 바이트들을 변환하고 그 결과를 encoded 버퍼에 담는다.
    // decoded 버퍼에서 소비된(인코드 된) 바이트의 개수를 반환한다.
include::codes/hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/HexEncoder.java[lines=42..48]
----
<1> `decoded` 버퍼의 현재 위치(`position`) 값을 기록해 둔다.
<2> `decoded` 버퍼에 읽을 바이트들이 (하나 이상) 남아 있고 `encoded` 버퍼에 최소한 두 개의 바이트를 기록할 수 있는 동안 `encode(int, ByteBuffer)` 를 호출한다.
<3> `decoded` 버퍼의 위치(`position`)값과 미리 기록해 둔 값의 차이를 반환한다.

===== encode(ByteBuffer)

전달 받은 버퍼의 숫자들을 변환하고 그 결과를 새 버퍼에 담아 반환한다.

[source,java]
.HexEncoder.java#encode(ByteBuffer)
----
    // encoded 버퍼의 모든 바이트들을 인코딩하고 결과를 새 버퍼에 담아 반환한다.
    // 반환되는 버퍼는 바로 읽을 수 있는 상태이다.
include::codes/hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/HexEncoder.java[lines=57..61]
----
<1> `decoded` 버퍼에서 읽을 수 있는 바이트 개수의 두 배만큼의 용량을 가지는 버퍼를 생성한다.
<2> 두 버퍼를 `encode(ByteBuffer, ByteBuffer)` 메서드에 전달한다.
<3> 반환할 버퍼를 뒤집어(flip) 바로 읽을 수 있는 상태로 만든다.

===== encode(String, Charset)

전달받은 문자열을 인코드한 후 그 결과를 문자열로 반환한다. 명시된 문자셋을 이용하여 바이트 배열을 구한다.

[source,java]
.HexEncoder.java#encode(String, Charset)
----
    // 주어진 문자열(encoded)을 변환하고 결과를 문자열로 반환한다.
    // 문자열(encoded)로부터 charset 을 이용하여 byte[] 를 얻어 변환한다.
include::codes/hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/HexEncoder.java[lines=71..76]
----
<1> `charset` 을 이용해 주어진 문자열에서 입력 배열을 생성한다.
<2> 두 배의 길이를 갖는 출력 배열을 생성한다.
<3> 이 두 배열을 감싸는 버퍼들을 `encoded(ByteBuffer, ByteBuffer)` 메서드에 전달한다.
<4> 출력 배열로부터 문자열을 생성하고 반환한다.

==== HexDecoder.java

`Base 16 Encoding` 으로 인코드된 문자들을 다시 숫자들로 변환하기 위한 인터페이스이다.

[source,java]
.HexDecoder.java
----
@FunctionalInterface
public interface HexDecoder {

    // 버퍼에서 hex 문자 두개를 변한하여 한 개의 숫자(0 ~ 255)를 반환한다.
    // 버퍼에서 읽을 수 있는 바이트들의 개수가 두 개 이하이면 BufferUnderflowException 을 던진다.
    int decodeOctet(ByteBuffer encoded);
}
----

`HexDecoder` 인터페이스에도 `HexEncoder` 인터페이스에 정의된 `default` 메서드들에 대응하는 `default` 메서드들이 정의되어 있다.

===== decode(ByteBuffer, ByteBuffer)

[source,java]
.HexDecoder.java#decode(ByteBuffer, ByteBuffer)
----
    // 입력 버퍼(encoded)에서 문자들을 변한하여 출력 버퍼(decoded)에 담는다.
    // 출력 버퍼에 추가된 바이트의 개수를 반환한다.
include::codes/hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/HexDecoder.java[lines=42..48]
----
<1> `encoded` 버퍼에 읽을 바이트의 개수가 2개 이상 있고 `decoded` 버퍼에 쓸 수 있는 공간이 남아 있는 동안
<2> `decodeOctet(ByteBuffer)` 메서드에 `encoded` 버퍼를 전달하고 반환된 값을 `decoded` 버퍼에 담는다.

===== decode(ByteBuffer)

[source,java]
.HexDecoder.java#decode(ByteBuffer)
----
    // 주어진 버퍼(encoded)에 남아있는(remaining) 문자들을 디코드한 후 그 결과를 새 버퍼에 담아 반환한다.
include::codes/hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/HexDecoder.java[lines=57..61]
----
<1> `encoded` 버퍼에서 읽을 수 있는 바이트 개수의 절반 만큼의 버퍼를 생성하고
<2> `encode(ByteBuffer, ByteBuffer)` 메서드에 전달해서 디코드한다.
<3> 반환할 버퍼를 뒤집어(`flip()`) 읽을 수 있는 상태로 만든다.

===== decode(String, Charset)

[source,java]
.HexDecoder.java#decode(String, Charset)
----
    // 주어진 문자열(encoded)를 디코드하고 그 결과를 새로운 문자열로 반환한다.
    // 디코드된 바이트들과 명시된 문자셋(charset)을 이용하여 문자열을 생성한다.
include::codes/hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/HexDecoder.java[lines=71..76]
----
<1> 문자열로부터 입력 배열을 생성한다.
<2> 절반 만큼의 길이를 갖는 출력 배열을 생성한다.
<3> `decode(ByteBuffer, ByteBuffer)` 메서드에 전달해서 디코드한다.
<4> 출력 배열과 명시된 `charset` 을 이용하여 문자열을 생성한 후 반환한다.

==== HexOutputStream.java

기록되는 바이트들을 자동으로 `base16` 문자들로 바꾸어 기록하는 `OutputStream` 이다. {apidocs-javase}/java/io/FilterOutputStream.html[`java.io.FilterInputStream`] 클래스를 확장하여 작성되었다.

[source,java]
.HexOutputStream.java
----
public class HexOutputStream extends FilterOutputStream {

    // out: 인코딩된 문자들이 기록될 스트림
    // enc: 숫자들을 문자들로 변환하기 위한 인코더
    public HexOutputStream(final OutputStream out, final HexEncoder enc) {
        super(out); // <1>
        this.enc = enc;
    }

    protected HexEncoder enc;
    private ByteBuffer buf; // 인코딩 작업에 사용할 버퍼
}
----
<1> `out` 인자를 `FilterOutputStream` 클래스의 생성자로 넘긴다.

[TIP]
====
`FilterOutputStream` 클래스의 생성자는 `out` 인자가 `null` 인지 확인하지 않는다. 대신 `protected` 접근자를 가지는 `out` 필드를 통해 값을 수정할 수 있다. 아마도 `null` 을 이용하여 생성한 후 실제로 사용할 필요가 있을 때 게으르게(lazily) 초기화될(initialized) 수 있는 여지를 남겨둔 듯 하다. `HexOutputStream` 클래스의 생성자도 `enc` 인자가 `null` 인지 확인하지 않는다. `null` 값을 이용하여 생성한 후 다음과 같이 사용할 수도 있다.
[source,java]
----
final OutputStream hos = new HexOutputStream(null, null) {
    @Override
    public void write(final byte b) throws IOException {
        if (out == null) out = openFile(); // lazily
        if (enc == null) enc = loadEncoder(); // lazily
        super.write(b);
    }
};
----
====

{apidocs-javase}/java/io/OutputStream.html[`java.io.OutputStream`] 클래스와 {apidocs-javase}/java/io/FilterOutputStream.html[`java.io.FilterInputStream`] 클래스의 메서드들이 동작하는 방식을 확인해보자.

===== OutputStream#close()

스트림을 닫고 사용되고 있는 자원들을 해제한다.

{apidocs-javase}/java/io/FilterOutputStream.html#close--[`FilterOutputStream#close()`] 메서드는 `flush()` 메서드를 호출하고 `out` 객체의 `close()` 메서드를 호출한다. `HexOutputStream` 클래스에서는 별도로 재정의하지 않았다.

===== OutputStream#flush()

데이터가 중간에 쌓여(buffered)있다면 실제 목적지로 밀어낸다.

{apidocs-javase}/java/io/FilterOutputStream.html#flush--[`FilterOutputStream#flush()`] 메서드는 `out` 객체의 `flush()` 메서드를 호출한다. `HexOutputStream` 클래스에서는 별도로 재정의하지 않았다.

===== OutputStream#write(byte[] b)

주어진 배열의 (모든) 값을 기록한다. `write(b, 0, b.length)` 를 호출한 것과 동일한 효과를 가져야 한다.

{apidocs-javase}/java/io/FilterOutputStream.html#write-byte:A-[`FilterOutputStream#write(byte[\])`] 메서드는 `write(b,0,b.length)` 를 호출한다. `HexOutputStream` 클래스에서는 별도로 재정의하지 않았다.

===== OutputStream#write(byte[] b, int off, int len)

주어진 배열의 `off` 위치부터 `len` 만큼의 바이트들을 기록한다.

{apidocs-javase}/java/io/FilterOutputStream.html#write-byte:A-int-int-[`FilterOutputStream#write(byte[\],int,int)`] 메서드는 각 바이트를 `write(int)` 메서드에 하나씩 전달한다. `HexOutputStream` 클래스에서는 별도로 재정의하지 않았다.

===== OutputStream#write(int b)

주어진 바이트를 기록한다. 하위 8 개의 비트들만 사용되고 상위 24 개의 비트들은 무시된다.

{apidocs-javase}/java/io/FilterOutputStream.html#write-int-[`FilterOutputStream#write(int)`] 메서드는 `out` 객체의 `write(int)` 메서드에 주어진 값을 전달한다. `HexOutputStream` 클래스에서는 다음과 같이 재정의되었다.

[source,java]
.HexOutputStream.java#write(int)
----
    // 주어진 바이트를 두개의 hex 문자로 변환하여 기록한다.
include::codes/hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/HexOutputStream.java[lines=50..60]
----
<1> `buf` 가 `null` 이면 두개의 hex 문자를 담을수 있을 만큼의 크기로 생성한다.
<2> `HexEncoder#encodeOctet(int, ByteBuffer)` 메서드를 이용해 주어진 바이트를 변환한다.
<3> 변환된 두개의 문자들을 `out` 에 기록한다.

[CAUTION]
====
`FilterOutputStream` 클래스의 `flush()` 메서드와 `close()` 메서드는 `out` 필드가 `null` 인지 확인하지 않는다.
[source,java]
.FilterOutputStream.java (http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7u40-b43/java/io/FilterOutputStream.java#FilterOutputStream.flush%28%29[7u40-b43])
----
public void flush() throws IOException {
    out.flush();
}
public void close() throws IOException {
    try {
      flush();
    } catch (IOException ignored) {
    }
    out.close();
}
----
이후의 소스를 보면 다음과 같이 개선되었지만 여전히 `flush()` 메서드에서는 `out` 필드가 `null` 인지 확인하지 않는다.
[source,java]
.FilterOutputStream.java (http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/java/io/FilterOutputStream.java#FilterOutputStream.flush%28%29[8u40-b25])
----
public void flush() throws IOException {
    out.flush();
}
public void close() throws IOException {
    try (OutputStream ostream = out) { // <1>
        flush(); // <2>
    }
}
----
<1> `ostream` 이 `null` 이면 `close()` 메서드를 호출하지 않는다.
<2> `flush()` 는 호출된다.
====

==== HexInputStream.java

`HexDecoder` 인터페이스를 이용하여 hex 문자들을 바이트로 변환해서 읽어들이는 `InputStream` 이다. {apidocs-javase}/java/io/FilterInputStream.html[`java.io.FilterInputStream`] 클래스를 확장하여 만들어졌다.

[source,java]
.HexInputStream.java
----
public class HexInputStream extends FilterInputStream {

    // in : 인코딩된 문자들을 읽을 스트림
    // dec: 문자들을 숫자들로 변환하기 위한 디코더
    public HexInputStream(final InputStream in, final HexDecoder dec) {
        super(in); // <1>
        this.dec = dec;
    }

    protected HexDecoder dec;
    private ByteBuffer buf; // 디코딩 작업에 사용할 버퍼
}
----
<1> `in` 인자를 `FilterInputStream` 클래스의 생성자에 전달한다.

이제 {apidocs-javase}/java/io/InputStream.html[`java.io.InputStream`] 클래스에 정의된 메서드들에 대해 알아보자.

===== InputStream#available()

블럭(blocked)되지 않고 한번에 읽을 수 있는 (혹은 건너 뛸 수 있는) 바이트의 개수를 반환한다. 스트림의 끝(`end-of-stream`)에 도달한 상태라면 `0` 을 반환한다. (어떤 서브클래스들은, `close()` 메서드를 통해 닫혔을 경우, `IOException` 을 던질 수도 있다.)

{apidocs-javase}/java/io/FilterInputStream.html#available--[`FilterInputStream#available()`] 메서드는 `in` 객체의 `available()` 값을 반환한다. `HexInputStream` 클래스는 그 절반에 해당하는 값을 반환하도록 재정의되었다. (두 개의 바이트를 읽고 하나로 변환하므로 가용한 바이트의 개수도 반으로 줄였다.)

[source,java]
.HexInputStream.java#available()
----
include::codes/hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/HexInputStream.java[lines=55..58]
----

[CAUTION]
====
`available()` 메서드가 반환하는 값을 최적의(optimal) 버퍼 크기로 오해하면 안된다. 몇몇 `InputStream` 클래스들은 읽을 수 있는 모든 바이트들의 개수를 반환하다.

[source,java]
.WrongIoUtil.java#copy(File,File)
----
void dangerous(final File src, final File dst) throws IOException {
    try(InputStream in = new FileInputStream(src)) {
        try(OutputStream out = new FileOutputStream(dst)) {
            final byte[] buf = new byte[in.available()]; // <1>
            for (int len; (len = in.read(buf)) != -1; ) {
                out.write(buf, 0, len);
            }
            out.flush();
        }
    }
}
----
<1> `in` 객체의 `available()` 메서드가 파일(`src`)의 전체 크기를 반환할 수도 있다.
====

===== InputStream#close()

스트림을 닫고 사용되고 있는 리소스들을 해제한다.

{apidocs-javase}/java/io/FilterInputStream.html#close--[`FilterInputStream#cloes()`] 메서드는 `in` 객체에 `close()` 메서드를 호출한다. `HexInputStream` 클래스는 별도로 재정의하지 않는다.

===== InputStream#mark(int readlimit)

현재 위치를 표시(mark)한 후 `reset()` 메서드를 통해 다시 그 위치부터 읽을 수 있게 한다. `reset()` 메서드를 호출하기 전에 `readlimit` 보다 많은 바이트들이 소비되면 표시가 무효화(invalidate)된다.

{apidocs-javase}/java/io/FilterInputStream.html#mark-int-[`FilterInputStream#mark(int)`] 메서드는 주어진 값을 `in` 객체의 `mark(int)` 메서드에 전달한다. `HexInputStream` 클래스는 다음과 같이 주어진 값의 두 배에 해당하는 값을 사용하도록 재정의되었다.

[source,java]
.HexInputStream.java#mark(int)
----
include::codes/hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/HexInputStream.java[lines=70..73]
----
CAUTION: `readlimit` 의 값이 `Integer.MAX_VALUE / 2` 보다 클 경우의 결과는 예상할 수 없다.

[NOTE]
====
`FilterInputStream` 클래스의 `mark(int)` 메서드와 `reset()` 메서드는 `synchronized` 메서드로 구현되었다.
[source,java]
.java.io.FilterInputStream.java#mark(int)
----
    public synchronized void mark(int readlimit) {
        in.mark(readlimit);
    }
----
[source,java]
.java.io.FilterInputStream.java#reset()
----
    public synchronized void reset() throws IOException {
        in.reset();
    }
----
`HexInputStream` 클래스도 `mark(int)` 메서드를 `synchronized` 키워드를 추가하여 재정의하였다.
====

===== InputStream#markSupported()

`mark()` 메서드와 `reset()` 메서드를 지원하는지 확인한다.

{apidocs-javase}/java/io/FilterInputStream.html#markSupported--[`FilterInputStream#markSupported()`] 메서드는 `in` 객체의 `markSupported()` 값를 반환한다. `HexInptuStream` 클래스는 별도로 재정의하지 않았다.

===== InputStream#read()

바이트 하나를 읽는다. 반환되는 값은 `0` 부터 `255` 까지의 양수이다. 스트림의 끝(`end-of-stream`) 에 도달했으면 `-1` 을 반환한다. 이 메서드는 유효한 데이터가 준비될 때까지 블럭된다.

{apidocs-javase}/java/io/FilterInputStream.html#read--[`FilterInputStream#read()`] 메서드는 `in` 객체의 `read()` 메서드가 반환하는 값을 반환한다. `HexInputStream` 클래스는 아래와 같이 바이트 두 개를 읽어서 하나로 변환한 후 반환하도록 재정의되었다.

[source,java]
.HexInputStream.java#read()
----
    // 두 개의 문자를 읽어서 하나의 숫자로 변환한 후 반환한다.
include::codes/hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/HexInputStream.java[lines=84..103]
----
<1> `buf` 의 값이 아직 `null` 이면 두개의 hex 문자를 담을 수 있을 만큼의 크기로 생성한다.
<2> 첫번째 바이트를 읽고 `buf` 에 담는다. 그 값이 `-1` 이면 `-1` 을 반환한다.
<3> 두번째 바이트를 읽고 `buf` 에 담는다. 그 값이 `-1` 이면 `EOFException` 을 던진다. (올바르게 인코드되었다면 두 개의 hex 문자들이 올바르게 읽혀져야 한다.)
<4> `HexDecoder` 인터페이스의 `decodeOctet(ByteBuffer)` 메서드를 이용하여 디코딩한 값을 반환한다.

===== InputStream#read(byte[] b)

주어진 배열의 첫 번째 위치부터 (최대) 배열의 길이만큼 바이트를 읽은 후 실제로 읽힌 바이트 개수를 반환한다. 이미 스트림의 끝(`end-of-stream`)에 도달했다면 `-1` 을 반환한다. 배열의 크기보다 작은 수 많큼 읽힐 수도 있다. 이 메서드는 유효한 데이터가 준비될 때까지 블럭된다. `b` 의 길이(`length`) 가 `0` 이면 `0` 을 반환한다. `read(b, 0, b.length)` 를 호출한 것과 같은 효과를 가진다.


[CAUTION]
====
주어진 배열(`b`)의 길이(`length`)가 `0` 이면 스트림의 끝(`end-of-stream`)에 도달한 것과는 상관없이 무조건 `0` 을 반환할 수 있다는 것에 주의하자.
====

[NOTE]
====
전달될 배열의 길이가 `0` 보다 크다면 `0` 을 반환하지 않는다. (적어도 한 개 이상의 바이트가 읽힐 때까지 블럭된다.)
====

{apidocs-javase}/java/io/FilterInputStream.html#read-byte:A-[`FilterInputStream#read(byte[\])`] 메서드는 `read(byte[], int, int)` 메서드에 `b`, `0`, `b.length` 를 전달하고 그 결과값을 반환한다. `HexInputStream` 클래스는 별도로 재정의하지 않았다.

===== InputStream#read(byte[] b, int off, int len)

주어진 배열에 `off` 위치부터 최대 `len` 만큼의 바이트를 기록한 후 실제로 읽힌 바이트의 개수를 반환한다. 이미 스트림의 끝(`end-of-stream`)에 도달했다면 `-1` 을 반환한다. `len` 값보다 적은 수의 바이트들이 읽힐 수도 있다. 이 메서드는 유효한 데이터가 준비될 때까지 블럭된다. `len` 값이 `0` 이면 `0` 을 반환한다.

{apidocs-javase}/java/io/FilterInputStream.html#read-byte:A-int-int-[`FilterInputStream#read(byte[\],int,int)`] 메서드는 `in` 객체의 `read(byte[], int, int)` 메서드에 주어진 인자들을 전달한 후 그 결과값을 반환한다. `HexInputStream` 클래스는 다음과 같이 각각의 바이트들을 `read()` 메서드를 통해 읽도록 재정의 되었다.

[source,java]
.HexInputStream.java#read(byte[],int,int)
----
include::codes/hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/HexInputStream.java[lines=118..139]
----
<1> `len` 만큼 `read()` 메서드가 반환하는 값으로 배열의 값을 변경한다. `read()` 메서드가 `-1` 을 반환하기 전까지 반복한다. 첫 번째 호출이 `-1` 을 반환하면 `-1` 을 반환한다.

[CAUTION]
====
`read(byte[])` 메서드와 마찬가지로 `len` 값이 `0` 이면 스트림의 끝(`end-of-stream`)에 도달한 것과는 상관없이 무조건 `0` 을 반환할 수 있다.
====

===== InputStream#reset()

`mark(int)` 메서드가 호출된 시점으로 스트림의 위치를 조정한다. 일반(general) 계약(contract, 규약) 사항은 좀 더 복잡하다.

* `markSupported` 메서드가 `true` 를 반환하는 경우,
** 스트림이 생성된 이후 아직 `mark` 메서드가 호출되지 않았거나 마지막으로 호출된 `mark` 메서드의 `readlimit` 값보다 많은 바이트를 이미 읽은 상태라면 `IOException` 을 던질(might) 수 있다.
** `IOException` 을 던지지 않았다면 마지막으로 `mark` 메서드가 호출된 이후 읽은 모든 바이트들을 (혹은 `mark` 메서드가 호출되지 않았다면 파일의 처음부터) 다시 읽을 수 있는 상태로 리셋된다. 그 후에 `reset` 메서드가 호출된 시점 이후의 바이트들이 읽혀진다.
* `markSupported` 메서드가 `false` 를 반한하는 경우,
** `reset` 메서드가 `IOException` 을 던질(may) 수 있다.
** `IOException` 을 던지지 않았다면 스트림의 형(type)과 그 스트림 객체가 생성된 방식에 의해 (미리) 정해진 상태로 리셋된다. 이후 읽는 바이트들은 스트림 형(type)에 따라 결정된다.

{apidocs-javase}/java/io/FilterInputStream.html#reset--[`FilterInptuStream#reset()`] 메서드는 `in` 객체에 `reset()` 메서드를 호출한다. `HexInputStream` 클래스에서는 별도로 재정의 하지 않았다.

===== InputStream#skip(long n)

`n` 만큼의 바이트를 건너뛴다. (버린다). `n` 보다 적게 건너 뛴(`0` 만큼일 수도 있는) 값이 반환될 수 있다.

{apidocs-javase}/java/io/FilterInputStream.html#skip-long-[`FilterInputStream#skip(long)`] 메서드는 `in.skip(n)` 값을 반환한다. `HexInputStream` 클래스는 아래와 같이 주어진 값의 두 배만큼 시도하고 홀수만큼 건너뛰었으면 무조건 하나를 더 소비한다.

[source,java]
.HexInputStream.java#skip(long)
----
include::codes/hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/HexInputStream.java[lines=152..162]
----
<1> `n` 의 두 배에 해당하는 값 만큼 시도한다.
<2> 실제로 건너뛴 개수가 홀수이면 하나를 더 읽어서 버린다.
<3> 실제로 건너 뛴 바이트 개수의 절반에 해당하는 값을 반환한다.

==== FilterChannel.java

이제 `HexOutputStream` 클래스와 `HexInputStream` 클래스가 수행하는 기능을 `java.nio.channels` 패키지에 정의된 클래스들을 사용하여 구현해 보자. `FilterOutputStream` 과 `FilterInputStream` 에 해당하는 클래스들이 존재하지 않으므로 `WritableByteChannel` 인터페이스와 `ReadableByteChanel` 인터페이스의 공통 부모인 `java.nio.channels.Channel` 인터페이스를 구현하는 클래스를 하나 정의하고 공통의 기능을 미리 구현하도록 하겠다.

[source,java]
.FilterChannel.java
----
public class FilterChannel<T extends Channel> implements Channel {

    // channel : 실제 데이터가 기록되거나 읽혀질 채널
    public FilterChannel(final T channel) {
        super();
        this.channel = channel;
    }

    protected T channel;
}
----

===== Channel#isOpen()

채널이 열려 있는지 확인한다. `HexChannel#isOpen()` 메서드는 `channel` 의 `isOpen()` 을 호출하도록 구현되었다.

[source,java]
.FilterChannel.java#isOpen()
----
include::codes/hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/FilterChannel.java[lines=45..48]
----
<1> `channel` 이 `null` 이면 `NullPointerException` 이 발생한다.

===== Channel#close();

채널을 닫는다. `FilterChannel#close()` 메서드는 `channel` 이 `null` 이 아닐 경우에 한해 `channel` 에 직접 호출하도록 구현되었다.

[source,java]
.FilterChannel.java#close()
----
include::codes/hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/FilterChannel.java[lines=57..62]
----

==== WritableFilterChannel.java

`FilterChannel` 클래스를 확장하여 `WritableByteChannel` 형의 객체를 `channel` 의 값으로 사용하는 클래스이다.

[source,java]
.WritableFilterChannel.java
----
public class WritableFilterChannel
        extends FilterChannel<WritableFilterChannel>
        implements WritableByteChannel {

    public WritableFilterChannel(final WritableByteChannel channel) {
        super(channel);
    }
}
----

[NOTE]
====
아래와 같이 `WritableByteChannel` 을 확장하는 특정 형태의 클래스들을 위한 구현도 가능하다.
[source,java]
.WritableFilterChannel.java
----
public class TypedWritableFilterChannel<T extends WritableByteChannel>
        extends FilterChannel<T>
        implements WritableByteChannel {

    public WritableFilterChannel(final T channel) {
        super(channel);
    }
}
----
====

===== WritableByteChannel#write(ByteBuffer)

아래와 같이 `channel` 필드에 직접 호출하도록 구현되었다.

[source,java]
----
include::codes/hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/WritableFilterChannel.java[lines=48..51]
----

==== ReadableFilterChannel.java

`FilterChannel` 클래스를 확장하여 `ReadableByteChannel` 형의 객체를 `channel` 필드의 값으로 사용하는 클래스이다.

[source,java]
.ReadableFilterChannel.java
----
public class ReadableFilterChannel
        extends FilterChannel<ReadableByteChannel>
        implements ReadableByteChannel {

    public ReadableFilterChannel(final ReadableByteChannel channel) {
        super(channel);
    }
}
----

===== ReadableByteChannel#read(ByteBuffer)

아래와 같이 `channel` 필드에 직접 호출하도록 구현되었다.

[source,java]
----
include::codes/hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/ReadableFilterChannel.java[lines=48..51]
----

==== WritableHexChannel.java

`HexEncoder` 인터페이스를 이용해 `write(ByteBuffer)` 메서드에 전달된 바이트들을 `base16` 문자들로 변환하여 기록하는 체널이다.

[source,java]
.WritableHexChannel.java
----
public class WritableHexChannel extends WritableFilterChannel {

    // channel: 변환된 문자들을 기록할 채널
    // encoder: 숫자를 문자로 변활할 때 사용할 인코더
    public WritableHexChannel(final WritableByteChannel channel,
                              final HexEncoder encoder) {
        super(channel);
        this.encoder = encoder;
    }

    // 숫자들을 문자들로 변환하기 위해 사용할 인코더
    protected HexEncoder encoder;
}
----

===== write(ByteBuffer)

`write(ByteBuffer)` 메서드를 다음과 같이 재정의하였다.

[source,java]
.WritableHexChannel.java#write(ByteBuffer)
----
include::codes/hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/WritableHexChannel.java[lines=50..58]
----
<1> `src` 에 남아 있는 바이트 개수의 두배의 용량을 가지는 버퍼를 생성한다.
<2> `HexEncoder` 인터페이스의 `encode(ByteBuffer, ByteBuffer)` 메서드를 이용하여 변환한다.
<3> 변환된 바이트들을 `channel` 에 기록한다.

==== ReadableHexChannel.java

`HexDecoder` 인터페이스를 이용하여 `base16` 으로 변환된 문자들을 바이트로 변환하는 채널이다.

[source,java]
.ReadableHexChannel.java
----
public class ReadableHexChannel extends ReadableHexChannel {

    // 변환된 문자들을 읽을 채널
    // 문자들을 숫자들로 변환하기 위한 디코더
    public ReadableHexChannel(final ReadableByteChannel channel,
                              final HexDecoder decoder) {
        super(channel);
        this.decoder = decoder;
    }

    protected HexDecoder decoder;
}
----

===== ReadableHexChannel#read(ByteBuffer)

`read(ByteBuffer)` 메서드를 다음과 같이 재정의하였다.

[source,java]
.ReadableHexChannel.java#read(ByteBuffer)
----
include::codes/hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/ReadableHexChannel.java[lines=53..69]
----
<1> `dst` 에 담을 수 있는 개수의 두 배만큼의 용량을 가지는 버퍼를 생성한다.
<2> `channel` 로부터 바이트들을 읽는다. 스트림의 끝(`end-of-stream`)에 도달했으면 `-1` 을 반환한다.
<3> 읽은 개수가 홀수라면 하나를 더 읽는다.
<4> `HexDecoder` 인터페이스의 `decode(ByteBuffer, ByteBuffer)` 메서드를 이용해 디코드한다.

=== Exercises

. `HexEncoder.java` 에 배열을 이용하는 메서드를 구현하라.
+
[source,java]
.HexEncoder#encode(byte[],int,int,byte[],int)
----
// inarr 의 inoff 부터 inlen 만큼의 숫자를 인코딩하고 결과를 outarr 의 outoff 부터 기록한다.
default void encode(final byte[] inarr, final int inoff, final int inlen,
                    final byte[] outarr, final int outoff) {
    // @todo: implement
    // 인자들의 유효성을 검증하자.
    // outarr 의 outoff 부터 최소한 몇 개의 배열공간이 필요할까?
}
----
. `HexDcoder.java` 에 배열을 이용하는 메서드를 구현하라.
+
[source,java]
.HexDecoder#encode(byte[],int,int,byte[],int)
----
// inarr 의 inoff 부터 inlen 만큼의 문자를 디코딩하고 결과를 outarr 의 outoff 부터 기록한다.
default void decode(final byte[] inarr, final int inoff, final int inlen,
                    final byte[] outarr, final int outoff) {
    // @todo: implement
    // 인자들의 유효성을 검증하자. inlen 이 홀수이면 유효한 값일까?
    // outarr 의 outoff 부터 최소한 몇 개의 배열공간이 필요할까?
}
----

=== hex-codec-lib

hex-codec-api 모듈에 정의되어 있는 두개의 인터페이스를 구현한 모듈이다.

==== HexEncoderImpl.java

`HexEncoder` 인터페이스를 구현한 클래스이다.

[source,java]
.HexEncoderImpl.java
----
public class HexEncoderImpl implements HexEncoder {
    // @todo: implement
}
----

===== encodeNibble(int)

`encodeOctet(int, ByteBuffer)` 메서드를 구현하기 전에 네 개의 비트로 이루어진 숫자(nibble)를 한 개의 hex 문자로 변환하는 메서드를 정의해 보자.

[source,java]
.HexEncoderImpl.java#encodeNibble(int)
----
include::codes/hex-codec-lib/src/main/java/com/github/jinahya/verbose/hex/HexEncoderImpl.java[lines=19..35]
----
<1> 주어진 값이 `0` 부터 `9` 까지의 값이면 그값에 `48` 을 더해서 `'0'`(`48`)부터 `'9'`(`57`)까지의 값을 반환하고
<2> `10` 부터 `15` 까지의 값이면 그 값에 `55` 를 더해서 `'A'`(`65`)부터 `'F'`(`70`)까지의 값을 반환한다.

[CAUTION]
====
전달된 `decoded` 의 값이 `0` 부터 `15` 까지의 값이라 가정한 코드이다. `encodedNibble(int)` 메서드가 `private` 메서드이고 `HexEncoderImpl` 클래스에서만 사용된다는 점을 감안하더라도 좋은 코드라 할 수 없다. 다음과 같이 수정하면 더 좋은 코드가 아닐까 한다.
[source,java]
----
        switch (decoded & 15) { // 하위 네 개의 비트만 사용한다.
            // ...
        }
----
====

===== encodeOctet(int, ByteBuffer)

이제 `encodeOctet(int, ByteBuffer)` 메서드를 다음과 같이 구현할 수 있다.

[source,java]
.HexEncoderImpl.java#encodeOctet(int,ByteBuffer)
----
include::codes/hex-codec-lib/src/main/java/com/github/jinahya/verbose/hex/HexEncoderImpl.java[lines=37..46]
----
<1> `decoded` 를 오른쪽으로 `4` 만큼 쉬프트한 후 `15` 와 AND 연산하여 상위 네 개의 비트가 표현하는 첫번째 nibble을 구한다.
<2> `decoded` 와 `15` 를 AND 연산하여 하위 네 개의 비트가 표현하는 두번째 nibble을 구한다.

[TIP]
====
만약 `encodeNibble(int)` 메서드가 주어진 값의 하위 네 개의 비트만 사용한다는 것이 보장된다면 다음과 같이 호출할 수도 있다.
[source,java]
----
encoded.put((byte) encodeNibble(decoded >> 4));
encoded.put((byte) encodeNibble(decoded));
----
====

==== HexDecoderImpl.java

`HexDecoder` 인터페이스를 구현한 클래스이다.

[source,java]
.HexDecoderImpl.java
----
public class HexDecoderImpl implements HexDecoder {
    // @todo: implement
}
----

===== decodeNibble(int)

`decodeOctet(int)` 메서드를 구현하기 전에 한 개의 hex 문자를 네 개의 비트로 이루어진 숫자(nibble)로 변환하는 메서드를 정의해 보자.

[source,java]
.HexDecoderImpl#decodeNibble(int)
----
include::codes/hex-codec-lib/src/main/java/com/github/jinahya/verbose/hex/HexDecoderImpl.java[lines=19..42]
----
<1> 주어진 값이 `'0'`(`48`)부터 `'9'`(`57`)까지의 값이면 그 값에서 `48` 을 뺀 값을 반환한다.
<2> 대문자 `'A'`(`65`)부터 `'F'`(`70`) 까지의 값이면 그 값에서 `55` 를 뺀 값을 반환한다.
<3> 소문자 `'a'`(`97`) 부터 `'f'`(`102`) 까지의 값이라고 가정하고 그 값에서 `87` 를 뺀 값을 반환한다.

앞서 `HexEncoderImpl` 클래스는 무조건 대문자로 변환했지만 여기서는 소문자로 변환된 값들도 모두 처리한다.

[CAUTION]
====
역시나 가정해서 처리한 부분이 있다. 다음과 같이 모든 경우에 대해 확실한 코드를 사용하는 편이 더 훌륭한 코드가 아닐까 한다.
[source,java]
----
            case 'a': //  97, 0x61
            case 'b': //  98, 0x62
            case 'c': //  99, 0x63
            case 'd': // 100, 0x64
            case 'e': // 101, 0x65
            case 'f': // 102, 0x66
                return encoded - 87; // to 10 ~ 15
            default:
                throw new IllegalArgumentException(
                        "unknown hex value: " + encoded);
----
====

===== decodeOctet(ByteBuffer)

이제 `decodeOctet(ByteBuffer)` 메서드를 다음과 같이 구현할 수 있다.

[source,java]
.HexdecoderImpl.java#decodeOctet(ByteBuffer)
----
include::codes/hex-codec-lib/src/main/java/com/github/jinahya/verbose/hex/HexDecoderImpl.java[lines=44..52]
----
첫 번째 문자를 디코드하고 윈쪽으로 `4` 만큼 옮긴 값에 두번째 문자를 디코드한 값을 OR 연산하여 반환한다.

[TIP]
====
만약 `decodeNibble(int)` 메서드가 네 개의 비트로 이루어진 숫자를 반환한다는 것이 보장된다면 다음과 같이 구현할 수도 있다.
[source,java]
----
return decodeNibble(decoded.get()) << 4 | decodeNibble(decoded.get());
----
====

==== Unit Testing Strategy

`HexEncoderImpl` 클래스와 `HexDecoderImpl` 클래스가 정상적으로 동작한다는 것을 어떻게 시험해야 할까? 단순히 시험에 사용할 데이터를 생성하고 `HexEncoderImpl` 객체를 이용해 인코드한 후 다시 `HexDecoderImpl` 객체로 디코드한 값을 비교하면 되지 않을까? 이 경우에 결과적으로 처음 입력한 데이터와 같은 결과를 얻었다 하더라도 두 클래스가 올바르게 작성되었다고 볼 수 없다. 두 클래스 모두 숫자 `15` 에 `'F'` 가 아닌 `'G'` 를 사용했더라도 시험을 통과하게 된다. 때문에 `HexEncoderImpl` 클래스와 `HexDecoderImpl` 클래스를 독립적으로 분리하여 각각의 기능을 비교해서 시험해 볼 수 있는 별도의 자료 혹은 라이브러리를 사용할 필요가 있다.

===== RFC 4648: The Base16, Base32, and Base64 Data Encodings

{rfc-4648}[RFC 4648] 의 http://tools.ietf.org/html/rfc4648#section-10[10. Test Vectors] 항목에 우리가 사용할 수 있는 테스트 벡터가 정의되어 있다. 아래와 같이 클래스를 하나를 만들고 테스트 벡터를 정의하였다.
[source,java]
.Rfc4648TestVectors.java#BASE16
----
include::codes/hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/Rfc4648TestVectors.java[lines=62..70]
----
`BASE16` 필드를 직접 노출하지 않고 다음과 같이 메서드를 하나 추가하여 데이터를 사용할 수 있게 했다.
[source,java]
.Rfc4648TestVectors.java#base16(BiConsumer)
----
    // 주어진 BiConsumer 의 accept(String, String) 메서드에 BASE16 리스트의 값들을 전달한다.
    // 첫 번째 인자에는 BASE16 리스트의 짝수 번째 문자열을,
    // 두 번째 인자에는 BASE16 리스트의 홀수 번째 문자열을 제공한다.
include::codes/hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/Rfc4648TestVectors.java[lines=97..101]
----

===== Apache Commons Codec

{project-commons-codec}[Apache Commons Codec] 라이브러리의 {apidocs-commons-codec}/org/apache/commons/codec/binary/Hex.html[`Hex`] 클래스를 이용하여 인코딩/디코딩 결과를 교차 확인한다.

===== Guava: Google Core Libraries for Java

{project-guava}[Guava] 라이브러리에 포함된 {apidocs-guava}/com/google/common/io/BaseEncoding.html[`BaseEncoding`] 클래스를 이용하여 인코딩/디코딩 결과를 교차 확인한다.

==== HexEncoderImplTest.java

`HexEncoderImpl` 클래스의 기능을 확인하기 위한 시험클래스이다.


===== encodeVerboseCompareRfc4648()

우선 아래와 같이 `Rfc4648TestVectors` 클래스를 이용하여 `HexEncoderImpl` 클래스의 기능을 시험한다.

[source,java]
.HexEncoderImplTest.java#encodeVerboseCompareRfc4648()
----
include::codes/hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/HexEncoderImplTest.java[lines=37..42]
----
<1> 테스트 벡터에 정의된 값(`d`, 인코드할 값)을 변환한 후 제시된 값(`e`, 인코드된 결과값)과 비교한다.

===== encodeVerboseDecodeCommons()

아래는 `Hex` 클래스를 이용하여 `HexEncoderImpl` 클래스의 기능을 확인하는 시험항목이다.

[ditaa]
....
              +------------+                 +-----+
  created --> |{io}        |                 |{io} |
              | HexEncoder | --> encoded --> | Hex |
     ^        |cBLU        |                 |cGRE | --> decoded
     |        +------------+                 +-----+
     |                                                      ^
     |                                                      |
     \----------------------- compare ----------------------/
....

[source,java]
.HexEncoderImplTest.java#encodeVerboseDecodeCommons()
----
include::codes/hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/HexEncoderImplTest.java[lines=49..57]
----
<1> 인코드할 배열을 생성한다.
<2> 두배의 크기를 가지는 배열을 생성한 후 `encode(ByteBuffer, ByteBuffer)` 메서드를 이용하여 인코드한다.
<3> 인코드된 결과를 {apidocs-commons-codec}/org/apache/commons/codec/binary/Hex.html#decode(byte%5B%5D)[`Hex#decode(byte[\])`] 메서드를 이용하여 디코드한다.
<4> 처음 생성한 배열과 디코드한 결과를 비교한다.

===== encodeVerboseDecodeGuava()

아래는 `BaseEncoding` 클래스를 이용하여 `HexEncoderImpl` 클래스의 기능을 확인하는 시험항목이다.

[ditaa]
....
              +------------+                 +--------------+
  created --> |{io}        |                 |{io}          |
              | HexEncoder | --> encoded --> | BaseEncoding |
     ^        |cBLU        |                 |cGRE          | --> decoded
     |        +------------+                 +--------------+
     |                                                               ^
     |                                                               |
     \--------------------------- compare ---------------------------/
....

[source,java]
.HexEncoderImplTest.java#encodeVerboseDecodeGuava()
----
include::codes/hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/HexEncoderImplTest.java[lines=62..71]
----
<1> 인코드한 값을 {apidocs-guava}/com/google/common/io/BaseEncoding.html#decode(java.lang.CharSequence)[`BaseEncoding.decode(CharSequence)`] 메서드를 이용하여 디코드한다.

==== HexDecoderImplTest.java

`HexDecoderImpl` 클래스의 기능을 확인하기 위한 시험클래스이다.

===== decodeVerboseCompareRfc4648()

`HexEncderImplTest` 클래스와 마찬가지로 `Rfc4648TestVectors` 클래스를 이용하여 `HexDecoderImpl` 클래스의 기능을 시험한다.

[source,java]
.HexDecoderImplTest.java#decodeVerboseCompareRfc4648()
----
include::codes/hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/HexDecoderImplTest.java[lines=36..41]
----
<1> 테스트 벡터에 정의된 값(`e`, 인코드된 값)을 디코딩한 후 제시된 값(`d`, 디코딩된 값)과 비교한다.

===== encodeCommonsDecodeVerbose()

다음 메서드는 `Hex` 클래스를 이용하여 `HexDecoderImpl` 클래스의 기능을 확인한다.

[ditaa]
....
              +-----+                 +------------+
  created --> |{io} |                 |{io}        |
              | Hex | --> encoded --> | HexDecoder |
     ^        |cBLU |                 |cGRE        | --> decoded
     |        +-----+                 +------------+
     |                                                      ^
     |                                                      |
     \----------------------- compare ----------------------/
....

[source,java]
.HexDecoderImplTest.java#encodeCommonsDecodeVerbose()
----
include::codes/hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/HexDecoderImplTest.java[lines=46..54]
----
<1> 입력 배열을 생성한다.
<2> 생성한 배열을 {apidocs-commons-codec}/org/apache/commons/codec/binary/Hex.html#encode(byte%5B%5D)[`Hex#encode(byte[\])`] 메서드를 이용해 인코드한다.
<3> 절반 크기의 출력 배열을 생성한 후 `decode(ByteBuffer, ByteBuffer)` 메서드를 이용해 디코드한다.
<4> 입력 배열과 출력 배열을 비교한다.

===== encodeGuavaDecodeVerbose()

다음 메서드는 `BaseEncoding` 클래스를 이용하여 `HexDecoderImpl` 클래스의 기능을 확인한다.

[ditaa, "encodeGuavaDecodeVerbose"]
....
              +--------------+                 +------------+
  created --> |{io}          |                 |{io}        |
              | BaseEncoging | --> encoded --> | HexDecoder |
     ^        |cBLU          |                 |cGRE        | --> decoded
     |        +--------------+                 +------------+
     |                                                               ^
     |                                                               |
     \--------------------------- compare ---------------------------/
....

[source,java]
.HexDecoderImplTest.java#encodeGuavaDecodeVerbose()
----
include::codes/hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/HexDecoderImplTest.java[lines=59..68]
----
<1> 입력 배열을 {apidocs-guava}/com/google/common/io/BaseEncoding.html#decode(java.lang.CharSequence)[`BaseEncoding#decode(CharSequence)`] 메서드를 이용해 디코드한다.

==== HexStreamTest.java

`HexIputStream` 클래스와 `HexOutputStream` 클래스를 시험하기 위한 클래스이다.

[ditaa, "encodeDecodeFile"]
....
                +----------------------------------+
  created ----> |{io}                              |
                |FileInputStream -> HexOutputStream|
     ^          |cBLU                              | -----\
     |          +----------------------------------+      |

 (compare)                                             encoded

     |          +----------------------------------+      |
     v          |{io}                              | <----/
                |FileOutputStream <- HexInputStream|
  decoded <---- |cGRE                              |
                +----------------------------------+
....

[source,java]
.HexStreamTest.java#encodeDecodeFile()
----
public class HexStreamTest {

    @Test
    public void encodeDecodeFile()
            throws IOException, NoSuchAlgorithmException {
        // @todo: implement
    }
}
----

파일(`created`)을 하나 생성하고 무작위로 내용을 채운다.

[source,java]
.HexStreamTest.java#encodeDecodeFile()
----
include::codes/hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/HexStreamTest.java[lines=28..35]
----
<1> VM 이 종료될 때 파일을 삭제한다.

파일(`encoded`)을 하나 더 만들고 `HexOutputStream` 클래스를 이용하여 복사한다. (인코드한다.)

[source,java]
.HexStreamTest.java#encodeDecodeFile()
----
include::codes/hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/HexStreamTest.java[lines=36..45]
----

또 다른 파일(`decoded`)에 `HexInputStream` 클래스를 이용하여 복사한다. (디코드한다.)

[source,java]
.HexStreamTest.java#encodeDecodeFile()
----
include::codes/hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/HexStreamTest.java[lines=46..55]
----

세 개의 파일들은 각각의 크기가 다음의 조건을 만족한다.

[source,java]
.HexStreamTest.java#encodeDecodeFile()
----
include::codes/hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/HexStreamTest.java[lines=56..57]
----

처음 생성한 파일(`created`)과 마지막의 디코드된 파일(`decoded`)의 내용을 비교한다.

[source,java]
.HexStreamTest.java#encodeDecodeFile()
----
include::codes/hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/HexStreamTest.java[lines=58..62]
----

==== HexChannelTest.java

[ditaa, "encodeDecodePath"]
....
                +---------------------------------+
  created ----> |{io}                             |
                |FileChannel -> WritableHexChannel|
     ^          |cBLU                             | -----\
     |          +---------------------------------+      |

 (compare)                                            encoded

     |          +---------------------------------+      |
     v          |{io}                             | <----/
                |FileChannel <- ReadableHexChannel|
  decoded <---- |cGRE                             |
                +---------------------------------+
....

===== algorithms()

파일을 비교할 때 사용할 알고리즘을 제공하는 메서드이다.

[source,java]
.HexChannelTest.java#algorithms()
----
include::codes/hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/HexChannelTest.java[lines=39..42]
----

===== encodeDecodePath(String)

[source,java]
.HexChannelTest.java#encodeDecodePath(String)
----
    @Test(dataProvider = "algorithms")
    public void encodeDecodePath(final String algorithm)
            throws IOException, NoSuchAlgorithmException {
        // @implement
    }
----

파일을 하나(`created`) 생성하고 무작위로 내용을 채운 다음 메시지 다이제스트 값을 미리 계산해 놓는다.

[source,java]
.HexChannelTest.java#encodeDecodePath(String)
----
include::codes/hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/HexChannelTest.java[lines=55..61]
----
<1> {apidocs-javase}/java/nio/file/StandardOpenOption.html#DSYNC[`StandardOpenOption#DSYNC`] 옵션을 명시해서 갱신되는 내용이 저장소에 동시에(synchronously) 기록되도록 한다.

파일을 하나 더(`encoded`) 생성하고 `WritableHexChannel` 클래스를 이용해서 복사한다. (인코드한다.)

[source,java]
.HexChannelTest.java#encodeDecodePath(String)
----
include::codes/hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/HexChannelTest.java[lines=62..71]
----
<1> {apidocs-javase}/java/nio/file/StandardOpenOption.html#DELETE_ON_CLOSE[`StandardOpenOption#DELETE_ON_CLOSE`] 옵션을 명시해서 `close()` 될 때 파일이 삭제도록 한다.

또 다른 파일(`decoded`)에 `ReadableHexChannel` 클래스를 이용해서 복사한 후 (디코드한 후) 메시지 다이제스트 값을 구한다.

[source,java]
.HexChannelTest.java#encodeDecodePath(String)
----
include::codes/hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/HexChannelTest.java[lines=72..82]
----

두 메시지 다이제스트 값을 비교한다.

[source,java]
.HexChannelTest.java#encodeDecodePath(String)
----
include::codes/hex-codec-lib/src/test/java/com/github/jinahya/verbose/hex/HexChannelTest.java[lines=83..83]
----

=== Exercises
. `HexEncoderImpl#encodeNible(int)` 과 `HexDecoderImpl#decodeNibble(int)` 의 `switch` 구문을 `if/else` 구문으로 바꿔보자.
+
. 시험 클래스를 하나 추가하고 클래스 파일의 처음 4 개의 바이트들을 `base16` 으로 출력해 보자.
+
[source,java]
.ClassFileTest.java#magic()
----
public class ClassFileTest {

    @Test
    public void magic() throws IOException {
        final Class<?> type = getClass();
        final String name = type.getSimpleName() + ".class";
        try (InputStream input = type.getResourceAsStream(name)) {
            final byte[] decoded = new byte[4];
            new DataInputStream(input).readFully(decoded);
            final byte[] encoded = new byte[decoded.length << 1];
            new HexEncoderImpl().encode(wrap(decoded), wrap(encoded));
            System.out.println("magic: " + new String(encoded, US_ASCII));
        }
    }
}
----
+
[NOTE]
====
`class` 파일의 첫 네 바이트는 클래스 파일임을 식별할 수 있는 고정 값이다.

https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.1[Chapter 4. The `class` File Format (The Java(R) Virtual Machine Specification)]
====
. 테스트 클래스를 하나 추가하고 자신의 이름을 `base16` 으로 출력해보자.
+
[source,java]
.CharsetTest.java#name()
----
public class CharsetTest {

    @Test
    public void name() throws CharacterCodingException {
        final String decodedName = "길동";
        System.out.printf("%-20s %-20s%n", "canonical", "encoded");
        System.out.printf("%1$20s %1$20s%n", "--------------------");
        for (Entry<String, Charset> entry : availableCharsets().entrySet()) {
            final String canonical = entry.getKey();
            final Charset charset = entry.getValue();
            if (!charset.canEncode()) {
                continue;
            }
            final CharsetEncoder encoder = charset.newEncoder();
            try {
                if (!encoder.canEncode(decodedName)) {
                    continue;
                }
            } catch (final UnsupportedOperationException uoe) { // :(
                continue;
            }
            final ByteBuffer decodedBuffer
                    = encoder.encode(CharBuffer.wrap(decodedName));
            final ByteBuffer encodedBuffer
                    = new HexEncoderImpl().encode(decodedBuffer);
            final byte[] bytes = encodedBuffer.array();
            final int offset
                    = encodedBuffer.arrayOffset() + encodedBuffer.position();
            final int length = encodedBuffer.remaining();
            final String encodedName
                    = new String(bytes, offset, length, US_ASCII);
            System.out.printf("%-20s %-20s%n", canonical, encodedName);
        }
    }
}
----
. 다음 조건을 만족하는 메서드를 구현해 보자.
+
[source, java]
----
// input 에서 output 으로 데이터를 복사한다.
// length 만큼의 길이를 가지는 버퍼를 사용한다.
// 최대 count 만큼만 복사한다. (count 가 -1L 이면 스트림(input)의 끝까지 복사한다.)
// 실제로 복사된 바이트 개수를 반환한다.
// (count 가 -1L 이 아닐 경우 count 보다 같거나 작아야 한다.)
long copy(InputStream input, OutputStream output, int length, long count)
    throws IOException {
    // @todo: implement
    // 인자들의 유효성을 확인하자.
    return 0L;
}
----
. 다음 조건을 만족하는 메서드를 구현해 보자.
+
[source, java]
----
// input 에서 output 으로 데이터를 복사한다.
// 주어진 버퍼(buffer)를 사용한다.
// 최대 count 만큼만 복사한다. (count 가 -1L 이면 스트림(input)의 끝까지 복사한다.)
// 실제로 복사된 바이트 개수를 반환한다.
// (count 가 -1L 이 아닐 경우 count 보다 같거나 작아야 한다.)
long copy(InputStream input, OutputStream output, byte[] buffer, long count)
    throws IOException {
    // @todo: implement
    // 인자들의 유효성을 확인하자.
    return 0L;
}
----
. 다음 조건을 만족하는 메서드를 구현해 보자.
+
[source,java]
----
// readable 에서 writable 로 데이터를 복사한다.
// capacity 만큼의 용량을 가지는 버퍼를 사용한다.
// 최대 count 만큼만 복사한다. (count 가 -1L 이면 채널(readable)의 끝까지 복사한다.)
// 실제로 복사된 바이트 개수를 반환한다.
// (count 가 -1L 이 아닐 경우 count 보다 같거나 작아야 한다.)
long copy(ReadableByteChannel readable, WritableByteChannel writable,
          int capacity, long count)
    throws IOException {
    // @todo: implement
    // 인자들의 유효성을 확인하자.
    return 0L;
}
----
. 다음 조건을 만족하는 메서드를 구현해 보자.
+
[source,java]
----
// readable 에서 writable 로 데이터를 복사한다.
// 주어진 버퍼(buffer)를 사용한다.
// 최대 count 만큼만 복사한다. (count 가 -1L 이면 채널(readable)의 끝까지 복사한다.)
// 실제로 복사된 바이트 개수를 반환한다.
// (count 가 -1L 이 아닐 경우 count 보다 같거나 작아야 한다.)
long copy(ReadableByteChannel readable, WritableByteChannel writable,
          ByteBuffer buffer, long count)
    throws IOException {
    // @todo: implement
    // 인자들의 유효성을 확인하자.
    return 0L;
}
----

=== percent-codec-api

다음과 같이 정의된 URL이 있다고 가정하자.

----
http://.../files/{file}?descriptor={descriptor}
----

`{file}` 부분과 `{descriptor}` 부분에 `a/b?c` 와 `e&f=g/h` 을 각각 대입하면 유효하지 않거나 의도하지 않은 값이 나온다.

----
http://.../files/a/b?c?descriptor=e&f=g/h
----

때문에 각 부분별로 허용되지 않는 문자들을 다음과 같이 적절하게 인코딩한 후 사용해야 한다.

----
http://.../files/a%2Fb%3Fc?descriptor=e%26f%3Dg%2Fh
----

https://tools.ietf.org/html/rfc3986[RFC 3986]의 https://tools.ietf.org/html/rfc3986#section-2.1https://tools.ietf.org/html/rfc3986#section-2.1[Percent-Encoding] 항목에 위 예시에서 사용된 방법이 정의되어 있다. 주어진 문자가 https://tools.ietf.org/html/rfc3986#section-2.3[Unreserved Characters] 항목에 정의된 범위(`알파벳`, `숫자`, `'-'`, `'.'`, `'_'`, `'~'`) 밖이면 `'%'` 하나와 두개의 `hex` 문자로 표현한다.

[NOTE]
====
http://docs.oracle.com/javase/8/docs/api/java/net/URLEncoder.html[`java.net.URLEncoder`] 와 http://docs.oracle.com/javase/8/docs/api/java/net/URLDecoder.html[`java.net.URLDecoder`] 는 해당 문서에 기술되어 있듯이 http://www.w3.org/TR/html5/forms.html#url-encoded-form-data[HTML]에 정의된 `application/x-www-form-urlencoded` 형식을 위한 코덱이다. `'~'` 대신 `'*'` 를 그대로 표기하며 공백 문자(`'{nbsp}'`)를 `"%20"` 이 아닌 `'+'` 로 인코딩한다. 아래 코드는 `"value"` 라는 필드 이름과 `"홍 길동"` 이라는 필드 값을 서버에 전달하는 예시 문서이다. (공백 문자(`'{nbsp}'`)가 `'+'` 로 인코딩되어 있다.)
----
POST /names HTTP/1.1
Host: www.example.com:80
Content-Type: application/x-www-form-urlencoded
Content-Length: 34

value=%ED%99%8D+%EA%B8%B8%EB%8F%99
----
====

==== PercentEncoder.java

Percent Encoding을 위한 인터페이스이다.

[source,java]
.PercentEncoder.java
----
@FunctionalInterface
public interface PercentEncoder {

    // 바이트(decoded)를 인코딩 한 후 결과(한 개 혹은 세 개의 문자)를 버퍼(encoded)에 담는다.
    // 버퍼(encoded)에 공간이 충분치 않으면 BufferOverflowException 을 던진다.
    void encodeOctet(final int decoded, final ByteBuffer encoded);
}
----

다음과 같은 default 메서드들이 정의되어 있다.

===== encode(ByteBuffer, ByteBuffer)

두 개의 버퍼를 전달받아 첫 번째 버퍼의 바이트들을 변환한 후 두 번째 버퍼에 담는다. `HexEncoder` 인터페이스와는 다르게 변환할 바이트가 몇 개의 문자로 변환될 지 알 수 없다. (알 수는 있지만 미리 알 필요가 없다고 상정한다.) 때문에 `encodeOcetet(int, ByteBuffer)` 메서드가 `BufferOverflowException` 을 던지는지 확인한다.
[source,java]
.PercentEncoder.java#encode(ByteBuffer, ByteBuffer)
----
    // decoded 버퍼의 바이트들을 인코드한 후 encoded 버퍼에 담는다.
    // decoded 버퍼에서 소비된 바이트 개수를 반환한다.
include::codes/percent-codec-api/src/main/java/com/github/jinahya/verbose/percent/PercentEncoder.java[lines=39..52]
----
<1> `decoded` 버퍼의 `position` 값을 기록해 둔다.
<2> `decoded` 버퍼에 인코드할 바이트가 남아있는 동안 반복한다.
<3> `encoded` 버퍼의 위치값을 기록해둔다.
<4> `encodeOctet` 메서드에 값을 전달한다.
<5> `encodeOctet` 메서드가 `BufferOverflowException` 을 던지면 두 버퍼의 위치값을 복구하고 반복 구문을 빠져나간다.
<6> 미리 기록해 둔 값과의 차이를 반환한다.

===== encode(ByteBuffer)

[source,java]
.PercentEncoder.java#encode(ByteBuffer)
----
    // decoded 버퍼의 바이트들을 인코드한 후 결과를 반환한다.
include::codes/percent-codec-api/src/main/java/com/github/jinahya/verbose/percent/PercentEncoder.java[lines=61..65]
----
<1> `decoded` 버퍼에 가용한 바이트 개수의 세 배에 해당하는 버퍼를 생성한다. (모든 바이트들이 `%XX` 형태로 변환된다고 가정한다.)
<2> `encode(ByteBuffer, ByteBuffer)` 메서드를 호출해 변한한다.
<3> `encoded` 버퍼를 뒤집어(flip) 읽을 수 있는 상태로 만든 후 반환한다.

===== encode(String, Charset)

[source,java]
.PercentEncoder.java#encode(String,Charset)
----
include::codes/percent-codec-api/src/main/java/com/github/jinahya/verbose/percent/PercentEncoder.java[lines=76..83]
----
<1> 문자열(`decoded`)에서 문자셋(`charset`)을 이용해 입력 배열을 구한다.
<2> 입력 배열 길이의 세 배에 해당하는 출력 배열을 생성한다. (`encode(ByteBuffer)` 메서드와 마찬가지로 모든 바이트들이 `%XX` 형태로 변환된다고 가정한다.)
<3> 두 배열을 감싸는(wrap) 버퍼들을 생성한 후 `encode(ByteBuffer, ByteBuffer)` 메서드를 호출하여 변한한다.
<4> 출력 배열에서 인코드된 만큼의 값들만으로 문자열을 생성하여 반환한다.

==== PercentDecoder.java

인코드된 문자들을 숫자로 디코드하기 위한 인터페이스이다.

[source,java]
.PercentDecoder.java
----
@FunctionalInterface
public interface PercentDecoder {

    // 버퍼(encoded)에서 필요한 만큼(1개 혹은 3개)의 문자를 디코드하고 그 결과를 반환한다.
    // 버퍼(encoded)에 필요한 만큼의 문자가 없으면 BufferUnderflowException 을 던진다.
    int decodeOctet(final ByteBuffer encoded);
}
----

===== decode(ByteBuffer, ByteBuffer)

두 개의 버퍼를 전달받아 첫 번째 버퍼의 문자들을 디코드한 숫자들을 두 번째 버퍼에 담는다. `HexDecoder` 인터페이스와는 다르게 몆 개의 문자가 필요한 지 알 수 없다. (알 수는 있지만 미리 알 필요가 없다고 상정한다.) 때문에 `decodeOcetet(ByteBuffer)` 메서드가 `BufferUnderflowException` 을 던지는지 확인한다.

[source,java]
.PercentDecoder.java#decode(ByteBuffer, ByteBuffer)
----
    // encoded 버퍼의 문자들을 디코드한 숫자들을 decoded 버프에 담는다.
    // decoded 버퍼에 추가된 숫자들의 개수를 반환한다.
include::codes/percent-codec-api/src/main/java/com/github/jinahya/verbose/percent/PercentDecoder.java[lines=37..50]
----
<1> `decoded` 버퍼의 현재 위치(`position`) 값을 기록한다.
<2> `decoded` 버퍼에 디코드된 바이트들를 담을 수 있는 동안 반복한다.
<3> `encoded` 버퍼의 위치값을 기록해둔다.
<4> `decode(ByteBuffer)` 에 `encoded` 버퍼를 전달하여 한 개 혹은 세 개의 문자를 한 개의 숫자로 디코드한 후 `decoded` 버퍼에 담는다.
<5> `BufferUnderflowException` 이 발생하면 `encoded` 버퍼의 위치값을 복귀시킨 후 순환 문을 빠져나간다.
<6> `decoded` 버퍼의 증가된 위치(`position`)와 이미 기록한 값(`decodedPosition`) 만큼의 차이를 반환한다.

===== decode(ByteBuffer)

[source,java]
.PercentDecoder.java#decode(ByteBuffer)
----
    // 주어진 버퍼(encoded)의 문자들을 디코드한 후 인코드된 숫자들을 새 버퍼에 담아 반환한다.
include::codes/percent-codec-api/src/main/java/com/github/jinahya/verbose/percent/PercentDecoder.java[lines=59..63]
----
<1> `encoded` 버퍼와 같은 용량의 버퍼를 생성한다. (모든 바이트들이 `%XX` 형태로 변환되었다고 가정한다.)
<2> `decode(ByteBuffer, ByteBuffer)` 메서드를 이용해 디코드한다.
<3> 반환할 버퍼(`decoded`)를 뒤집어(`flip()`) 읽을 수 있는 상태로 만든다.

===== decode(String, Charset)

[source,java]
.PercentDecoder.java#decode(String, Charset)
----
include::codes/percent-codec-api/src/main/java/com/github/jinahya/verbose/percent/PercentDecoder.java[lines=75..82]
----
<1> 문자열로부터 입력 배열을 생성한다.
<2> 입력 배열과 같은 크기를 가지는 출력 배열을 생성한다. (모든 숫자들이 `%XX` 형태로 변환되었다고 가정한다.)
<3> 두 배열을 감싸는(wrap) 버퍼들을 생성한 후 `decode(ByteBuffer, ByteBuffer)` 메서드을 이용해 변환한다.
<4> 변환된 출력 배열로부터 `charset` 을 이용해 출력 문자열을 생성한다.

==== Exercises
. `WritableHexChannel` 을 참고하여 `WritablePercentChannel` 클래스를 작성하라.
+
[source,java]
----
public class WritablePercentChannel implements WritableByteChannel {

    public WritablePercentChannel(final WritableByteChannel channel,
                                  final PercentEncoder encoder) {
        super();
        this.channel = channel;
        this.encoder = encoder;
    }

    @Override
    public boolean isOpen() {
        return channel.isOpen();
    }

    @Override
    public void close() throws IOException {
        if (channel != null) {
            channel.close();
        }
    }

    @Override
    public int write(final ByteBuffer src) throws IOException {
        // @todo: implement
        throw new UnsupportedOperationException("not implemented yet!");
    }

    protected WritableByteChannel channel;
    protected PercentEncoder encoder;
}
----
. `ReadableHexChannel` 클래스를 참고하여 `ReadablePercentChannel` 클래스를 작성하라.
+
[source,java]
----
public class ReadablePercentChannel implements ReadableByteChannel {

    public ReadablePercentChannel(final ReadableByteChannel channel,
                                  final PercentDecoder decoder) {
        super();
        this.channel = channel;
        this.decoder = decoder;
    }

    @Override
    public boolean isOpen() {
        return channel.isOpen();
    }

    @Override
    public void close() throws IOException {
        if (channel != null) {
            channel.close();
        }
    }

    @Override
    public int read(final ByteBuffer dst) throws IOException {
        // @todo: implement
        throw new UnsupportedOperationException("not implemented yet!");
    }

    protected ReadableByteChannel channel;
    protected PercentDecoder decoder;
}
----

=== percent-codec-lib

pecent-codec-api 에 정의된 인터페이스들을 구현한 모듈이다. hex-codec-api 와 hex-codec-lib 을 통해 하나의 octet 을 두개의 hex 문자로 변환하는 방법을 이미 구현했으므로 그 모듈들을 사용한다. 다음과 같이 의존성을 확인해 보자.

[source,text]
.dependency:tree
----
$ pwd
/.../path/to/.../verbose-java/percent-codec-lib
$ mvn dependency:tree -Dscope=runtime
...
[INFO] com.github.jinahya:percent-codec-lib:jar:<version>
[INFO] +- com.github.jinahya:hex-codec-api:jar:<version>:compile
[INFO] +- com.github.jinahya:hex-codec-lib:jar:<version>:runtime
[INFO] \- com.github.jinahya:percent-codec-api:jar:<version>:compile
...
$
----
hex-codec-api 를 compile scope 로 정의하여 구현작업에 사용되었고 hex-codec-lib 을 runtime scope 로 정의하여 실제로 동작할 때만 사용되도록 설정하였다.

==== PercentEncoderImpl.java

[source,java]
.HexEncoderImpl.java
----
public class HexEncoderImpl implements HexEncoder {

include::codes/percent-codec-lib/src/main/java/com/github/jinahya/verbose/percent/PercentEncoderImpl.java[lines=39..42]

include::codes/percent-codec-lib/src/main/java/com/github/jinahya/verbose/percent/PercentEncoderImpl.java[lines=71..73]
}
----
<1> `HexEncoder` 객체를 제공한다.
<2> `hexEncoderSupplier` 로부터 게으르게(lazily) 제공될 객체이다.

[source,java]
.HexEncoderImpl.java#PercentEncoderImpl()
----
include::codes/percent-codec-lib/src/main/java/com/github/jinahya/verbose/percent/PercentEncoderImpl.java[lines=49..51]
----
<1> SPI(Service Provider Interface) 를 통해 객체를 적재하고 제공하는 `Supplier` 이다.

===== encodeOctet(int, ByteBuffer)

다음과 같이 `encodeOctet(int, ByteBuffer)` 를 구현했다.

[source,java]
.PercentEncoderImpl.java#encodeOctet(int, ByteBuffer)
----
include::codes/percent-codec-lib/src/main/java/com/github/jinahya/verbose/percent/PercentEncoderImpl.java[lines=53..69]
----
<1> 인코딩할 필요가 없는 숫자는 그대로 버퍼에 담는다.
<2> 인코딩이 필요한 문자는 한 개의 `"%"` 를 버퍼에 담고
<3> 게으르게(lazily) 적재된 `HexEncoder` 객체의 `encodeOctet(int, ByteBuffer)` 메서드를 이용해 두개의 hex 문자를 버퍼이 담는다.

==== PercentDecoderImpl.java

[source,java]
.PercentEncoderImpl.java
----
public class PercentDecoderImpl implements PercentEncoder {

include::codes/percent-codec-lib/src/main/java/com/github/jinahya/verbose/percent/PercentDecoderImpl.java[lines=37..40]

include::codes/percent-codec-lib/src/main/java/com/github/jinahya/verbose/percent/PercentDecoderImpl.java[lines=63..65]
}
----

[source,java]
.PercentEncoderImpl.java#PercentEncoderImpl()
----
include::codes/percent-codec-lib/src/main/java/com/github/jinahya/verbose/percent/PercentDecoderImpl.java[lines=48..50]
----

다음과 같이 `decodeOctet(int, ByteBuffer)` 를 구현했다.

[source,java]
.PercentDecoderImpl.java#decodeOctet(ByteBuffer)
----
include::codes/percent-codec-lib/src/main/java/com/github/jinahya/verbose/percent/PercentDecoderImpl.java[lines=52..61]
----
<1> 첫 문자를 읽는다.
<2> 첫 문자가 `%` 이면 게으르게(lazily) 초기회된 `hexDecoder` 객체의 `decodeOctet(ByteBuffer)` 메서드를 이용하여 디코드한 값을 반환한다.
<3> 디코딩이 필요치 않은 문자는 그대로 반환한다.

==== Unit Testing Strategy
